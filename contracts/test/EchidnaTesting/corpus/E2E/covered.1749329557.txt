/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/access/AccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IAccessControl} from "./IAccessControl.sol";
   7 |     | import {Context} from "../utils/Context.sol";
   8 |     | import {ERC165} from "../utils/introspection/ERC165.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Contract module that allows children to implement role-based access
  12 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  13 |     |  * members except through off-chain means by accessing the contract event logs. Some
  14 |     |  * applications may benefit from on-chain enumerability, for those cases see
  15 |     |  * {AccessControlEnumerable}.
  16 |     |  *
  17 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  18 |     |  * in the external API and be unique. The best way to achieve this is by
  19 |     |  * using `public constant` hash digests:
  20 |     |  *
  21 |     |  * ```solidity
  22 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  23 |     |  * ```
  24 |     |  *
  25 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  26 |     |  * function call, use {hasRole}:
  27 |     |  *
  28 |     |  * ```solidity
  29 |     |  * function foo() public {
  30 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  31 |     |  *     ...
  32 |     |  * }
  33 |     |  * ```
  34 |     |  *
  35 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  36 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  37 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  38 |     |  *
  39 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  40 |     |  * that only accounts with this role will be able to grant or revoke other
  41 |     |  * roles. More complex role relationships can be created by using
  42 |     |  * {_setRoleAdmin}.
  43 |     |  *
  44 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  45 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  46 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  47 |     |  * to enforce additional security measures for this role.
  48 |     |  */
  49 |     | abstract contract AccessControl is Context, IAccessControl, ERC165 {
  50 |     |     struct RoleData {
  51 |     |         mapping(address account => bool) hasRole;
  52 |     |         bytes32 adminRole;
  53 |     |     }
  54 |     | 
  55 |     |     mapping(bytes32 role => RoleData) private _roles;
  56 |     | 
  57 | *   |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  61 |     |      * with an {AccessControlUnauthorizedAccount} error including the required role.
  62 |     |      */
  63 |     |     modifier onlyRole(bytes32 role) {
  64 | *   |         _checkRole(role);
  65 |     |         _;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev See {IERC165-supportsInterface}.
  70 |     |      */
  71 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  72 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Returns `true` if `account` has been granted `role`.
  77 |     |      */
  78 | *   |     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
  79 | *   |         return _roles[role].hasRole[account];
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
  84 |     |      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
  85 |     |      */
  86 | *   |     function _checkRole(bytes32 role) internal view virtual {
  87 | *   |         _checkRole(role, _msgSender());
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
  92 |     |      * is missing `role`.
  93 |     |      */
  94 | *   |     function _checkRole(bytes32 role, address account) internal view virtual {
  95 | *   |         if (!hasRole(role, account)) {
  96 |     |             revert AccessControlUnauthorizedAccount(account, role);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 102 |     |      * {revokeRole}.
 103 |     |      *
 104 |     |      * To change a role's admin, use {_setRoleAdmin}.
 105 |     |      */
 106 |     |     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
 107 |     |         return _roles[role].adminRole;
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Grants `role` to `account`.
 112 |     |      *
 113 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 114 |     |      * event.
 115 |     |      *
 116 |     |      * Requirements:
 117 |     |      *
 118 |     |      * - the caller must have ``role``'s admin role.
 119 |     |      *
 120 |     |      * May emit a {RoleGranted} event.
 121 |     |      */
 122 |     |     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 123 |     |         _grantRole(role, account);
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Revokes `role` from `account`.
 128 |     |      *
 129 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 130 |     |      *
 131 |     |      * Requirements:
 132 |     |      *
 133 |     |      * - the caller must have ``role``'s admin role.
 134 |     |      *
 135 |     |      * May emit a {RoleRevoked} event.
 136 |     |      */
 137 |     |     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 138 |     |         _revokeRole(role, account);
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @dev Revokes `role` from the calling account.
 143 |     |      *
 144 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 145 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 146 |     |      * if they are compromised (such as when a trusted device is misplaced).
 147 |     |      *
 148 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 149 |     |      * event.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - the caller must be `callerConfirmation`.
 154 |     |      *
 155 |     |      * May emit a {RoleRevoked} event.
 156 |     |      */
 157 |     |     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
 158 |     |         if (callerConfirmation != _msgSender()) {
 159 |     |             revert AccessControlBadConfirmation();
 160 |     |         }
 161 |     | 
 162 |     |         _revokeRole(role, callerConfirmation);
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 167 |     |      *
 168 |     |      * Emits a {RoleAdminChanged} event.
 169 |     |      */
 170 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 171 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 172 |     |         _roles[role].adminRole = adminRole;
 173 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
 178 |     |      *
 179 |     |      * Internal function without access restriction.
 180 |     |      *
 181 |     |      * May emit a {RoleGranted} event.
 182 |     |      */
 183 | *   |     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
 184 | *   |         if (!hasRole(role, account)) {
 185 | *   |             _roles[role].hasRole[account] = true;
 186 | *   |             emit RoleGranted(role, account, _msgSender());
 187 | *   |             return true;
 188 |     |         } else {
 189 |     |             return false;
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
 195 |     |      *
 196 |     |      * Internal function without access restriction.
 197 |     |      *
 198 |     |      * May emit a {RoleRevoked} event.
 199 |     |      */
 200 |     |     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
 201 |     |         if (hasRole(role, account)) {
 202 |     |             _roles[role].hasRole[account] = false;
 203 |     |             emit RoleRevoked(role, account, _msgSender());
 204 |     |             return true;
 205 |     |         } else {
 206 |     |             return false;
 207 |     |         }
 208 |     |     }
 209 |     | }
 210 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev External interface of AccessControl declared to support ERC165 detection.
   8 |     |  */
   9 |     | interface IAccessControl {
  10 |     |     /**
  11 |     |      * @dev The `account` is missing a role.
  12 |     |      */
  13 |     |     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev The caller of a function is not the expected one.
  17 |     |      *
  18 |     |      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
  19 |     |      */
  20 |     |     error AccessControlBadConfirmation();
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
  24 |     |      *
  25 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
  26 |     |      * {RoleAdminChanged} not being emitted signaling this.
  27 |     |      */
  28 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` is granted `role`.
  32 |     |      *
  33 |     |      * `sender` is the account that originated the contract call, an admin role
  34 |     |      * bearer except when using {AccessControl-_setupRole}.
  35 |     |      */
  36 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when `account` is revoked `role`.
  40 |     |      *
  41 |     |      * `sender` is the account that originated the contract call:
  42 |     |      *   - if using `revokeRole`, it is the admin role bearer
  43 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
  44 |     |      */
  45 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns `true` if `account` has been granted `role`.
  49 |     |      */
  50 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
  54 |     |      * {revokeRole}.
  55 |     |      *
  56 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
  57 |     |      */
  58 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Grants `role` to `account`.
  62 |     |      *
  63 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
  64 |     |      * event.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - the caller must have ``role``'s admin role.
  69 |     |      */
  70 |     |     function grantRole(bytes32 role, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Revokes `role` from `account`.
  74 |     |      *
  75 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
  76 |     |      *
  77 |     |      * Requirements:
  78 |     |      *
  79 |     |      * - the caller must have ``role``'s admin role.
  80 |     |      */
  81 |     |     function revokeRole(bytes32 role, address account) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Revokes `role` from the calling account.
  85 |     |      *
  86 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
  87 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
  88 |     |      * if they are compromised (such as when a trusted device is misplaced).
  89 |     |      *
  90 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
  91 |     |      * event.
  92 |     |      *
  93 |     |      * Requirements:
  94 |     |      *
  95 |     |      * - the caller must be `callerConfirmation`.
  96 |     |      */
  97 |     |     function renounceRole(bytes32 role, address callerConfirmation) external;
  98 |     | }
  99 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "../IERC20.sol";
   7 |     | import {IERC20Permit} from "../extensions/IERC20Permit.sol";
   8 |     | import {Address} from "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev An operation with an ERC20 token failed.
  24 |     |      */
  25 |     |     error SafeERC20FailedOperation(address token);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Indicates a failed `decreaseAllowance` request.
  29 |     |      */
  30 |     |     error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  34 |     |      * non-reverting calls are assumed to be successful.
  35 |     |      */
  36 | *   |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  37 | *   |         _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  42 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  43 |     |      */
  44 | *   |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  45 | *   |         _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  50 |     |      * non-reverting calls are assumed to be successful.
  51 |     |      */
  52 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  53 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  54 |     |         forceApprove(token, spender, oldAllowance + value);
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no
  59 |     |      * value, non-reverting calls are assumed to be successful.
  60 |     |      */
  61 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
  62 |     |         unchecked {
  63 |     |             uint256 currentAllowance = token.allowance(address(this), spender);
  64 |     |             if (currentAllowance < requestedDecrease) {
  65 |     |                 revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
  66 |     |             }
  67 |     |             forceApprove(token, spender, currentAllowance - requestedDecrease);
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  73 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  74 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  75 |     |      */
  76 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  77 |     |         bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
  78 |     | 
  79 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  80 |     |             _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
  81 |     |             _callOptionalReturn(token, approvalCall);
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
  87 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
  88 |     |      * @param token The token targeted by the call.
  89 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
  90 |     |      */
  91 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
  92 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
  93 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
  94 |     |         // the target address contains contract code and also asserts for success in the low-level call.
  95 |     | 
  96 | *   |         bytes memory returndata = address(token).functionCall(data);
  97 | *   |         if (returndata.length != 0 && !abi.decode(returndata, (bool))) {
  98 |     |             revert SafeERC20FailedOperation(address(token));
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 104 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 105 |     |      * @param token The token targeted by the call.
 106 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 107 |     |      *
 108 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 109 |     |      */
 110 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 111 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 112 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 113 |     |         // and not revert is the subcall reverts.
 114 |     | 
 115 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 116 |     |         return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;
 117 |     |     }
 118 |     | }
 119 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev The ETH balance of the account is not enough to perform the operation.
  12 |     |      */
  13 |     |     error AddressInsufficientBalance(address account);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev There's no code at `target` (it is not a contract).
  17 |     |      */
  18 |     |     error AddressEmptyCode(address target);
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev A call to an address target failed. The target may have reverted.
  22 |     |      */
  23 |     |     error FailedInnerCall();
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  27 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  28 |     |      *
  29 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  30 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  31 |     |      * imposed by `transfer`, making them unable to receive funds via
  32 |     |      * `transfer`. {sendValue} removes this limitation.
  33 |     |      *
  34 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  35 |     |      *
  36 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  37 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  38 |     |      * {ReentrancyGuard} or the
  39 |     |      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  40 |     |      */
  41 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  42 |     |         if (address(this).balance < amount) {
  43 |     |             revert AddressInsufficientBalance(address(this));
  44 |     |         }
  45 |     | 
  46 |     |         (bool success, ) = recipient.call{value: amount}("");
  47 |     |         if (!success) {
  48 |     |             revert FailedInnerCall();
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  54 |     |      * plain `call` is an unsafe replacement for a function call: use this
  55 |     |      * function instead.
  56 |     |      *
  57 |     |      * If `target` reverts with a revert reason or custom error, it is bubbled
  58 |     |      * up by this function (like regular Solidity function calls). However, if
  59 |     |      * the call reverted with no returned reason, this function reverts with a
  60 |     |      * {FailedInnerCall} error.
  61 |     |      *
  62 |     |      * Returns the raw returned data. To convert to the expected return value,
  63 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  64 |     |      *
  65 |     |      * Requirements:
  66 |     |      *
  67 |     |      * - `target` must be a contract.
  68 |     |      * - calling `target` with `data` must not revert.
  69 |     |      */
  70 | *   |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  71 | *   |         return functionCallWithValue(target, data, 0);
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  76 |     |      * but also transferring `value` wei to `target`.
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - the calling contract must have an ETH balance of at least `value`.
  81 |     |      * - the called Solidity function must be `payable`.
  82 |     |      */
  83 | *   |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  84 | *   |         if (address(this).balance < value) {
  85 |     |             revert AddressInsufficientBalance(address(this));
  86 |     |         }
  87 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  88 | *   |         return verifyCallResultFromTarget(target, success, returndata);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  93 |     |      * but performing a static call.
  94 |     |      */
  95 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
  96 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
  97 |     |         return verifyCallResultFromTarget(target, success, returndata);
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 102 |     |      * but performing a delegate call.
 103 |     |      */
 104 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 105 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 106 |     |         return verifyCallResultFromTarget(target, success, returndata);
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
 111 |     |      * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
 112 |     |      * unsuccessful call.
 113 |     |      */
 114 | *   |     function verifyCallResultFromTarget(
 115 |     |         address target,
 116 |     |         bool success,
 117 |     |         bytes memory returndata
 118 | *   |     ) internal view returns (bytes memory) {
 119 | *   |         if (!success) {
 120 | *   |             _revert(returndata);
 121 |     |         } else {
 122 |     |             // only check if target is a contract if the call was successful and the return data is empty
 123 |     |             // otherwise we already know that it was a contract
 124 | *   |             if (returndata.length == 0 && target.code.length == 0) {
 125 |     |                 revert AddressEmptyCode(target);
 126 |     |             }
 127 | *   |             return returndata;
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
 133 |     |      * revert reason or with a default {FailedInnerCall} error.
 134 |     |      */
 135 |     |     function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
 136 |     |         if (!success) {
 137 |     |             _revert(returndata);
 138 |     |         } else {
 139 |     |             return returndata;
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
 145 |     |      */
 146 | *   |     function _revert(bytes memory returndata) private pure {
 147 |     |         // Look for revert reason and bubble it up if present
 148 | *   |         if (returndata.length > 0) {
 149 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 150 |     |             /// @solidity memory-safe-assembly
 151 |     |             assembly {
 152 | *   |                 let returndata_size := mload(returndata)
 153 | *   |                 revert(add(32, returndata), returndata_size)
 154 |     |             }
 155 |     |         } else {
 156 |     |             revert FailedInnerCall();
 157 |     |         }
 158 |     |     }
 159 |     | }
 160 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Pausable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Context} from "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which allows children to implement an emergency stop
  10 |     |  * mechanism that can be triggered by an authorized account.
  11 |     |  *
  12 |     |  * This module is used through inheritance. It will make available the
  13 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  14 |     |  * the functions of your contract. Note that they will not be pausable by
  15 |     |  * simply including this module, only once the modifiers are put in place.
  16 |     |  */
  17 |     | abstract contract Pausable is Context {
  18 |     |     bool private _paused;
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev Emitted when the pause is triggered by `account`.
  22 |     |      */
  23 |     |     event Paused(address account);
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Emitted when the pause is lifted by `account`.
  27 |     |      */
  28 |     |     event Unpaused(address account);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev The operation failed because the contract is paused.
  32 |     |      */
  33 |     |     error EnforcedPause();
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev The operation failed because the contract is not paused.
  37 |     |      */
  38 |     |     error ExpectedPause();
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Initializes the contract in unpaused state.
  42 |     |      */
  43 |     |     constructor() {
  44 | *   |         _paused = false;
  45 |     |     }
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  49 |     |      *
  50 |     |      * Requirements:
  51 |     |      *
  52 |     |      * - The contract must not be paused.
  53 |     |      */
  54 |     |     modifier whenNotPaused() {
  55 | *   |         _requireNotPaused();
  56 |     |         _;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  61 |     |      *
  62 |     |      * Requirements:
  63 |     |      *
  64 |     |      * - The contract must be paused.
  65 |     |      */
  66 |     |     modifier whenPaused() {
  67 |     |         _requirePaused();
  68 |     |         _;
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  73 |     |      */
  74 | *   |     function paused() public view virtual returns (bool) {
  75 | *   |         return _paused;
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Throws if the contract is paused.
  80 |     |      */
  81 | *   |     function _requireNotPaused() internal view virtual {
  82 | *   |         if (paused()) {
  83 |     |             revert EnforcedPause();
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Throws if the contract is not paused.
  89 |     |      */
  90 |     |     function _requirePaused() internal view virtual {
  91 |     |         if (!paused()) {
  92 |     |             revert ExpectedPause();
  93 |     |         }
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Triggers stopped state.
  98 |     |      *
  99 |     |      * Requirements:
 100 |     |      *
 101 |     |      * - The contract must not be paused.
 102 |     |      */
 103 |     |     function _pause() internal virtual whenNotPaused {
 104 |     |         _paused = true;
 105 |     |         emit Paused(_msgSender());
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Returns to normal state.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - The contract must be paused.
 114 |     |      */
 115 |     |     function _unpause() internal virtual whenPaused {
 116 |     |         _paused = false;
 117 |     |         emit Unpaused(_msgSender());
 118 |     |     }
 119 |     | }
 120 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 | *   |     uint256 private constant NOT_ENTERED = 1;
 35 | *   |     uint256 private constant ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     /**
 40 |     |      * @dev Unauthorized reentrant call.
 41 |     |      */
 42 |     |     error ReentrancyGuardReentrantCall();
 43 |     | 
 44 |     |     constructor() {
 45 | *   |         _status = NOT_ENTERED;
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 50 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 51 |     |      * function is not supported. It is possible to prevent this from happening
 52 |     |      * by making the `nonReentrant` function external, and making it call a
 53 |     |      * `private` function that does the actual work.
 54 |     |      */
 55 |     |     modifier nonReentrant() {
 56 | *   |         _nonReentrantBefore();
 57 |     |         _;
 58 | *   |         _nonReentrantAfter();
 59 |     |     }
 60 |     | 
 61 | *   |     function _nonReentrantBefore() private {
 62 |     |         // On the first call to nonReentrant, _status will be NOT_ENTERED
 63 | *   |         if (_status == ENTERED) {
 64 |     |             revert ReentrancyGuardReentrantCall();
 65 |     |         }
 66 |     | 
 67 |     |         // Any calls to nonReentrant after this point will fail
 68 | *   |         _status = ENTERED;
 69 |     |     }
 70 |     | 
 71 | *   |     function _nonReentrantAfter() private {
 72 |     |         // By storing the original value once again, a refund is triggered (see
 73 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 74 | *   |         _status = NOT_ENTERED;
 75 |     |     }
 76 |     | 
 77 |     |     /**
 78 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 79 |     |      * `nonReentrant` function in the call stack.
 80 |     |      */
 81 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 82 |     |         return _status == ENTERED;
 83 |     |     }
 84 |     | }
 85 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {Math} from "./math/Math.sol";
  7 |     | import {SignedMath} from "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library Strings {
 13 |     |     bytes16 private constant HEX_DIGITS = "0123456789abcdef";
 14 | *   |     uint8 private constant ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev The `value` string doesn't fit in the specified `length`.
 18 |     |      */
 19 |     |     error StringsInsufficientHexLength(uint256 value, uint256 length);
 20 |     | 
 21 |     |     /**
 22 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 23 |     |      */
 24 | *   |     function toString(uint256 value) internal pure returns (string memory) {
 25 |     |         unchecked {
 26 | *   |             uint256 length = Math.log10(value) + 1;
 27 | *   |             string memory buffer = new string(length);
 28 | *   |             uint256 ptr;
 29 |     |             /// @solidity memory-safe-assembly
 30 |     |             assembly {
 31 | *   |                 ptr := add(buffer, add(32, length))
 32 |     |             }
 33 | *   |             while (true) {
 34 | *   |                 ptr--;
 35 |     |                 /// @solidity memory-safe-assembly
 36 |     |                 assembly {
 37 | *   |                     mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))
 38 |     |                 }
 39 | *   |                 value /= 10;
 40 | *   |                 if (value == 0) break;
 41 |     |             }
 42 | *   |             return buffer;
 43 |     |         }
 44 |     |     }
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 48 |     |      */
 49 |     |     function toStringSigned(int256 value) internal pure returns (string memory) {
 50 |     |         return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));
 51 |     |     }
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 55 |     |      */
 56 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 57 |     |         unchecked {
 58 |     |             return toHexString(value, Math.log256(value) + 1);
 59 |     |         }
 60 |     |     }
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 64 |     |      */
 65 | *   |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 66 | *   |         uint256 localValue = value;
 67 | *   |         bytes memory buffer = new bytes(2 * length + 2);
 68 | *   |         buffer[0] = "0";
 69 | *   |         buffer[1] = "x";
 70 | *   |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 71 | *   |             buffer[i] = HEX_DIGITS[localValue & 0xf];
 72 | *   |             localValue >>= 4;
 73 |     |         }
 74 | *   |         if (localValue != 0) {
 75 |     |             revert StringsInsufficientHexLength(value, length);
 76 |     |         }
 77 | *   |         return string(buffer);
 78 |     |     }
 79 |     | 
 80 |     |     /**
 81 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal
 82 |     |      * representation.
 83 |     |      */
 84 | *   |     function toHexString(address addr) internal pure returns (string memory) {
 85 | *   |         return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);
 86 |     |     }
 87 |     | 
 88 |     |     /**
 89 |     |      * @dev Returns true if the two strings are equal.
 90 |     |      */
 91 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 92 |     |         return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));
 93 |     |     }
 94 |     | }
 95 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  */
 20 |     | abstract contract ERC165 is IERC165 {
 21 |     |     /**
 22 |     |      * @dev See {IERC165-supportsInterface}.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
 25 |     |         return interfaceId == type(IERC165).interfaceId;
 26 |     |     }
 27 |     | }
 28 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     /**
  11 |     |      * @dev Muldiv operation overflow.
  12 |     |      */
  13 |     |     error MathOverflowedMulDiv();
  14 |     | 
  15 |     |     enum Rounding {
  16 |     |         Floor, // Toward negative infinity
  17 |     |         Ceil, // Toward positive infinity
  18 |     |         Trunc, // Toward zero
  19 |     |         Expand // Away from zero
  20 |     |     }
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Returns the addition of two unsigned integers, with an overflow flag.
  24 |     |      */
  25 |     |     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  26 |     |         unchecked {
  27 |     |             uint256 c = a + b;
  28 |     |             if (c < a) return (false, 0);
  29 |     |             return (true, c);
  30 |     |         }
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
  35 |     |      */
  36 |     |     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  37 |     |         unchecked {
  38 |     |             if (b > a) return (false, 0);
  39 |     |             return (true, a - b);
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
  45 |     |      */
  46 |     |     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  47 |     |         unchecked {
  48 |     |             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
  49 |     |             // benefit is lost if 'b' is also tested.
  50 |     |             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
  51 |     |             if (a == 0) return (true, 0);
  52 |     |             uint256 c = a * b;
  53 |     |             if (c / a != b) return (false, 0);
  54 |     |             return (true, c);
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Returns the division of two unsigned integers, with a division by zero flag.
  60 |     |      */
  61 |     |     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  62 |     |         unchecked {
  63 |     |             if (b == 0) return (false, 0);
  64 |     |             return (true, a / b);
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
  70 |     |      */
  71 |     |     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  72 |     |         unchecked {
  73 |     |             if (b == 0) return (false, 0);
  74 |     |             return (true, a % b);
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Returns the largest of two numbers.
  80 |     |      */
  81 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  82 |     |         return a > b ? a : b;
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Returns the smallest of two numbers.
  87 |     |      */
  88 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  89 |     |         return a < b ? a : b;
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  94 |     |      * zero.
  95 |     |      */
  96 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  97 |     |         // (a + b) / 2 can overflow.
  98 |     |         return (a & b) + (a ^ b) / 2;
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Returns the ceiling of the division of two numbers.
 103 |     |      *
 104 |     |      * This differs from standard division with `/` in that it rounds towards infinity instead
 105 |     |      * of rounding towards zero.
 106 |     |      */
 107 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
 108 |     |         if (b == 0) {
 109 |     |             // Guarantee the same behavior as in a regular Solidity division.
 110 |     |             return a / b;
 111 |     |         }
 112 |     | 
 113 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
 114 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or
 119 |     |      * denominator == 0.
 120 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by
 121 |     |      * Uniswap Labs also under MIT license.
 122 |     |      */
 123 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
 124 |     |         unchecked {
 125 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
 126 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
 127 |     |             // variables such that product = prod1 * 2^256 + prod0.
 128 |     |             uint256 prod0 = x * y; // Least significant 256 bits of the product
 129 |     |             uint256 prod1; // Most significant 256 bits of the product
 130 |     |             assembly {
 131 |     |                 let mm := mulmod(x, y, not(0))
 132 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
 133 |     |             }
 134 |     | 
 135 |     |             // Handle non-overflow cases, 256 by 256 division.
 136 |     |             if (prod1 == 0) {
 137 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
 138 |     |                 // The surrounding unchecked block does not change this fact.
 139 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
 140 |     |                 return prod0 / denominator;
 141 |     |             }
 142 |     | 
 143 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
 144 |     |             if (denominator <= prod1) {
 145 |     |                 revert MathOverflowedMulDiv();
 146 |     |             }
 147 |     | 
 148 |     |             ///////////////////////////////////////////////
 149 |     |             // 512 by 256 division.
 150 |     |             ///////////////////////////////////////////////
 151 |     | 
 152 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
 153 |     |             uint256 remainder;
 154 |     |             assembly {
 155 |     |                 // Compute remainder using mulmod.
 156 |     |                 remainder := mulmod(x, y, denominator)
 157 |     | 
 158 |     |                 // Subtract 256 bit number from 512 bit number.
 159 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
 160 |     |                 prod0 := sub(prod0, remainder)
 161 |     |             }
 162 |     | 
 163 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator.
 164 |     |             // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.
 165 |     | 
 166 |     |             uint256 twos = denominator & (0 - denominator);
 167 |     |             assembly {
 168 |     |                 // Divide denominator by twos.
 169 |     |                 denominator := div(denominator, twos)
 170 |     | 
 171 |     |                 // Divide [prod1 prod0] by twos.
 172 |     |                 prod0 := div(prod0, twos)
 173 |     | 
 174 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 175 |     |                 twos := add(div(sub(0, twos), twos), 1)
 176 |     |             }
 177 |     | 
 178 |     |             // Shift in bits from prod1 into prod0.
 179 |     |             prod0 |= prod1 * twos;
 180 |     | 
 181 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 182 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 183 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 184 |     |             uint256 inverse = (3 * denominator) ^ 2;
 185 |     | 
 186 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also
 187 |     |             // works in modular arithmetic, doubling the correct bits in each step.
 188 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 189 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 190 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 191 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 192 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 193 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 194 |     | 
 195 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 196 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 197 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 198 |     |             // is no longer required.
 199 |     |             result = prod0 * inverse;
 200 |     |             return result;
 201 |     |         }
 202 |     |     }
 203 |     | 
 204 |     |     /**
 205 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 206 |     |      */
 207 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 208 |     |         uint256 result = mulDiv(x, y, denominator);
 209 |     |         if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {
 210 |     |             result += 1;
 211 |     |         }
 212 |     |         return result;
 213 |     |     }
 214 |     | 
 215 |     |     /**
 216 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded
 217 |     |      * towards zero.
 218 |     |      *
 219 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 220 |     |      */
 221 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 222 |     |         if (a == 0) {
 223 |     |             return 0;
 224 |     |         }
 225 |     | 
 226 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 227 |     |         //
 228 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 229 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 230 |     |         //
 231 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 232 |     |         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 233 |     |         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 234 |     |         //
 235 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 236 |     |         uint256 result = 1 << (log2(a) >> 1);
 237 |     | 
 238 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 239 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 240 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 241 |     |         // into the expected uint128 result.
 242 |     |         unchecked {
 243 |     |             result = (result + a / result) >> 1;
 244 |     |             result = (result + a / result) >> 1;
 245 |     |             result = (result + a / result) >> 1;
 246 |     |             result = (result + a / result) >> 1;
 247 |     |             result = (result + a / result) >> 1;
 248 |     |             result = (result + a / result) >> 1;
 249 |     |             result = (result + a / result) >> 1;
 250 |     |             return min(result, a / result);
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /**
 255 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 256 |     |      */
 257 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 258 |     |         unchecked {
 259 |     |             uint256 result = sqrt(a);
 260 |     |             return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);
 261 |     |         }
 262 |     |     }
 263 |     | 
 264 |     |     /**
 265 |     |      * @dev Return the log in base 2 of a positive value rounded towards zero.
 266 |     |      * Returns 0 if given 0.
 267 |     |      */
 268 |     |     function log2(uint256 value) internal pure returns (uint256) {
 269 |     |         uint256 result = 0;
 270 |     |         unchecked {
 271 |     |             if (value >> 128 > 0) {
 272 |     |                 value >>= 128;
 273 |     |                 result += 128;
 274 |     |             }
 275 |     |             if (value >> 64 > 0) {
 276 |     |                 value >>= 64;
 277 |     |                 result += 64;
 278 |     |             }
 279 |     |             if (value >> 32 > 0) {
 280 |     |                 value >>= 32;
 281 |     |                 result += 32;
 282 |     |             }
 283 |     |             if (value >> 16 > 0) {
 284 |     |                 value >>= 16;
 285 |     |                 result += 16;
 286 |     |             }
 287 |     |             if (value >> 8 > 0) {
 288 |     |                 value >>= 8;
 289 |     |                 result += 8;
 290 |     |             }
 291 |     |             if (value >> 4 > 0) {
 292 |     |                 value >>= 4;
 293 |     |                 result += 4;
 294 |     |             }
 295 |     |             if (value >> 2 > 0) {
 296 |     |                 value >>= 2;
 297 |     |                 result += 2;
 298 |     |             }
 299 |     |             if (value >> 1 > 0) {
 300 |     |                 result += 1;
 301 |     |             }
 302 |     |         }
 303 |     |         return result;
 304 |     |     }
 305 |     | 
 306 |     |     /**
 307 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 308 |     |      * Returns 0 if given 0.
 309 |     |      */
 310 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 311 |     |         unchecked {
 312 |     |             uint256 result = log2(value);
 313 |     |             return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);
 314 |     |         }
 315 |     |     }
 316 |     | 
 317 |     |     /**
 318 |     |      * @dev Return the log in base 10 of a positive value rounded towards zero.
 319 |     |      * Returns 0 if given 0.
 320 |     |      */
 321 | *   |     function log10(uint256 value) internal pure returns (uint256) {
 322 | *   |         uint256 result = 0;
 323 |     |         unchecked {
 324 | *   |             if (value >= 10 ** 64) {
 325 |     |                 value /= 10 ** 64;
 326 |     |                 result += 64;
 327 |     |             }
 328 | *   |             if (value >= 10 ** 32) {
 329 |     |                 value /= 10 ** 32;
 330 |     |                 result += 32;
 331 |     |             }
 332 | *   |             if (value >= 10 ** 16) {
 333 | *   |                 value /= 10 ** 16;
 334 | *   |                 result += 16;
 335 |     |             }
 336 | *   |             if (value >= 10 ** 8) {
 337 | *   |                 value /= 10 ** 8;
 338 | *   |                 result += 8;
 339 |     |             }
 340 | *   |             if (value >= 10 ** 4) {
 341 | *   |                 value /= 10 ** 4;
 342 | *   |                 result += 4;
 343 |     |             }
 344 | *   |             if (value >= 10 ** 2) {
 345 | *   |                 value /= 10 ** 2;
 346 | *   |                 result += 2;
 347 |     |             }
 348 | *   |             if (value >= 10 ** 1) {
 349 | *   |                 result += 1;
 350 |     |             }
 351 |     |         }
 352 | *   |         return result;
 353 |     |     }
 354 |     | 
 355 |     |     /**
 356 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 357 |     |      * Returns 0 if given 0.
 358 |     |      */
 359 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 360 |     |         unchecked {
 361 |     |             uint256 result = log10(value);
 362 |     |             return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);
 363 |     |         }
 364 |     |     }
 365 |     | 
 366 |     |     /**
 367 |     |      * @dev Return the log in base 256 of a positive value rounded towards zero.
 368 |     |      * Returns 0 if given 0.
 369 |     |      *
 370 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 371 |     |      */
 372 |     |     function log256(uint256 value) internal pure returns (uint256) {
 373 |     |         uint256 result = 0;
 374 |     |         unchecked {
 375 |     |             if (value >> 128 > 0) {
 376 |     |                 value >>= 128;
 377 |     |                 result += 16;
 378 |     |             }
 379 |     |             if (value >> 64 > 0) {
 380 |     |                 value >>= 64;
 381 |     |                 result += 8;
 382 |     |             }
 383 |     |             if (value >> 32 > 0) {
 384 |     |                 value >>= 32;
 385 |     |                 result += 4;
 386 |     |             }
 387 |     |             if (value >> 16 > 0) {
 388 |     |                 value >>= 16;
 389 |     |                 result += 2;
 390 |     |             }
 391 |     |             if (value >> 8 > 0) {
 392 |     |                 result += 1;
 393 |     |             }
 394 |     |         }
 395 |     |         return result;
 396 |     |     }
 397 |     | 
 398 |     |     /**
 399 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 400 |     |      * Returns 0 if given 0.
 401 |     |      */
 402 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 403 |     |         unchecked {
 404 |     |             uint256 result = log256(value);
 405 |     |             return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);
 406 |     |         }
 407 |     |     }
 408 |     | 
 409 |     |     /**
 410 |     |      * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.
 411 |     |      */
 412 |     |     function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {
 413 |     |         return uint8(rounding) % 2 == 1;
 414 |     |     }
 415 |     | }
 416 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/properties/contracts/ERC4626/util/TestERC20Token.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {IERC20} from "../../util/IERC20.sol";
  5 |     | 
  6 | *   | contract TestERC20Token is IERC20 {
  7 |     |     string public name;
  8 |     |     string public symbol;
  9 |     |     uint8 public decimals;
 10 |     |     uint256 public totalSupply;
 11 | *   |     mapping(address => uint256) public balanceOf;
 12 |     |     mapping(address => mapping(address => uint256)) public allowance;
 13 |     | 
 14 | *   |     constructor(string memory _name, string memory _symbol, uint8 _decimals) {
 15 | *   |         name = _name;
 16 | *   |         symbol = _symbol;
 17 | *   |         decimals = _decimals;
 18 |     |     }
 19 |     | 
 20 | *   |     function approve(address spender, uint256 amount) public returns (bool) {
 21 | *   |         allowance[msg.sender][spender] = amount;
 22 |     | 
 23 | *   |         emit Approval(msg.sender, spender, amount);
 24 | *   |         return true;
 25 |     |     }
 26 |     | 
 27 | *   |     function transfer(address to, uint256 amount) public returns (bool) {
 28 | *   |         balanceOf[msg.sender] -= amount;
 29 | *   |         balanceOf[to] += amount;
 30 |     | 
 31 | *   |         emit Transfer(msg.sender, to, amount);
 32 | *   |         return true;
 33 |     |     }
 34 |     | 
 35 | *   |     function transferFrom(
 36 |     |         address from,
 37 |     |         address to,
 38 |     |         uint256 amount
 39 | *   |     ) public returns (bool) {
 40 | *   |         uint256 spenderAllowance = allowance[from][msg.sender];
 41 | *   |         if (spenderAllowance != type(uint256).max) {
 42 |     |             allowance[from][msg.sender] = spenderAllowance - amount;
 43 |     |         }
 44 |     | 
 45 | *   |         balanceOf[from] -= amount;
 46 | *   |         balanceOf[to] += amount;
 47 |     | 
 48 | *   |         emit Transfer(from, to, amount);
 49 | *   |         return true;
 50 |     |     }
 51 |     | 
 52 | *   |     function mint(address to, uint256 amount) public {
 53 | *   |         totalSupply += amount;
 54 | *   |         balanceOf[to] += amount;
 55 |     | 
 56 | *   |         emit Transfer(address(0), to, amount);
 57 |     |     }
 58 |     | 
 59 |     |     function burn(address from, uint256 amount) public {
 60 |     |         totalSupply -= amount;
 61 |     |         balanceOf[from] -= amount;
 62 |     | 
 63 |     |         emit Transfer(from, address(0), amount);
 64 |     |     }
 65 |     | 
 66 |     |     function forceApproval(
 67 |     |         address account,
 68 |     |         address spender,
 69 |     |         uint256 amount
 70 |     |     ) public {
 71 |     |         allowance[account][spender] = amount;
 72 |     |         emit Approval(account, spender, amount);
 73 |     |     }
 74 |     | }
 75 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/properties/contracts/util/Hevm.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Add the condition b to the assumption base for the current branch
 12 |     |     // This function is almost identical to require
 13 |     |     function assume(bool b) external;
 14 |     | 
 15 |     |     // Sets the eth balance of usr to amt
 16 |     |     function deal(address usr, uint256 amt) external;
 17 |     | 
 18 |     |     // Loads a storage slot from an address
 19 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 20 |     | 
 21 |     |     // Stores a value to an address' storage slot
 22 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 23 |     | 
 24 |     |     // Signs data (privateKey, digest) => (v, r, s)
 25 |     |     function sign(
 26 |     |         uint256 privateKey,
 27 |     |         bytes32 digest
 28 |     |     ) external returns (uint8 v, bytes32 r, bytes32 s);
 29 |     | 
 30 |     |     // Gets address for a given private key
 31 |     |     function addr(uint256 privateKey) external returns (address addr);
 32 |     | 
 33 |     |     // Performs a foreign function call via terminal
 34 |     |     function ffi(
 35 |     |         string[] calldata inputs
 36 |     |     ) external returns (bytes memory result);
 37 |     | 
 38 |     |     // Performs the next smart contract call with specified `msg.sender`
 39 |     |     function prank(address newSender) external;
 40 |     | 
 41 |     |     // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork
 42 |     |     function createFork(string calldata urlOrAlias) external returns (uint256);
 43 |     | 
 44 |     |     // Takes a fork identifier created by createFork and sets the corresponding forked state as active
 45 |     |     function selectFork(uint256 forkId) external;
 46 |     | 
 47 |     |     // Returns the identifier of the current fork
 48 |     |     function activeFork() external returns (uint256);
 49 |     | 
 50 |     |     // Labels the address in traces
 51 |     |     function label(address addr, string calldata label) external;
 52 |     | }
 53 |     | 
 54 |     | IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 55 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/properties/contracts/util/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IERC20 {
  5 |     |     /**
  6 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
  7 |     |      * another (`to`).
  8 |     |      *
  9 |     |      * Note that `value` may be zero.
 10 |     |      */
 11 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 12 |     | 
 13 |     |     /**
 14 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 15 |     |      * a call to {approve}. `value` is the new allowance.
 16 |     |      */
 17 |     |     event Approval(
 18 |     |         address indexed owner,
 19 |     |         address indexed spender,
 20 |     |         uint256 value
 21 |     |     );
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Returns the amount of tokens in existence.
 25 |     |      */
 26 |     |     function totalSupply() external view returns (uint256);
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Returns the amount of tokens owned by `account`.
 30 |     |      */
 31 |     |     function balanceOf(address account) external view returns (uint256);
 32 |     | 
 33 |     |     /**
 34 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 35 |     |      *
 36 |     |      * Returns a boolean value indicating whether the operation succeeded.
 37 |     |      *
 38 |     |      * Emits a {Transfer} event.
 39 |     |      */
 40 |     |     function transfer(address to, uint256 amount) external returns (bool);
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 44 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 45 |     |      * zero by default.
 46 |     |      *
 47 |     |      * This value changes when {approve} or {transferFrom} are called.
 48 |     |      */
 49 |     |     function allowance(
 50 |     |         address owner,
 51 |     |         address spender
 52 |     |     ) external view returns (uint256);
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 56 |     |      *
 57 |     |      * Returns a boolean value indicating whether the operation succeeded.
 58 |     |      *
 59 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 60 |     |      * that someone may use both the old and the new allowance by unfortunate
 61 |     |      * transaction ordering. One possible solution to mitigate this race
 62 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 63 |     |      * desired value afterwards:
 64 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 65 |     |      *
 66 |     |      * Emits an {Approval} event.
 67 |     |      */
 68 |     |     function approve(address spender, uint256 amount) external returns (bool);
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 72 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 73 |     |      * allowance.
 74 |     |      *
 75 |     |      * Returns a boolean value indicating whether the operation succeeded.
 76 |     |      *
 77 |     |      * Emits a {Transfer} event.
 78 |     |      */
 79 |     |     function transferFrom(
 80 |     |         address from,
 81 |     |         address to,
 82 |     |         uint256 amount
 83 |     |     ) external returns (bool);
 84 |     | 
 85 |     |     function decimals() external returns (uint8);
 86 |     | }
 87 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/properties/contracts/util/PropertiesHelper.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-or-later
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | abstract contract PropertiesAsserts {
   5 |     |     event LogUint256(string, uint256);
   6 |     |     event LogAddress(string, address);
   7 |     |     event LogString(string);
   8 |     | 
   9 |     |     event AssertFail(string);
  10 |     |     event AssertEqFail(string);
  11 |     |     event AssertNeqFail(string);
  12 |     |     event AssertGteFail(string);
  13 |     |     event AssertGtFail(string);
  14 |     |     event AssertLteFail(string);
  15 |     |     event AssertLtFail(string);
  16 |     | 
  17 |     |     function assertWithMsg(bool b, string memory reason) internal {
  18 |     |         if (!b) {
  19 |     |             emit AssertFail(reason);
  20 |     |             assert(false);
  21 |     |         }
  22 |     |     }
  23 |     | 
  24 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  25 | *   |     function assertEq(uint256 a, uint256 b, string memory reason) internal {
  26 | *   |         if (a != b) {
  27 | *   |             string memory aStr = PropertiesLibString.toString(a);
  28 | *   |             string memory bStr = PropertiesLibString.toString(b);
  29 | *   |             bytes memory assertMsg = abi.encodePacked(
  30 |     |                 "Invalid: ",
  31 | *   |                 aStr,
  32 |     |                 "!=",
  33 | *   |                 bStr,
  34 |     |                 ", reason: ",
  35 | *   |                 reason
  36 |     |             );
  37 | *   |             emit AssertEqFail(string(assertMsg));
  38 | *   |             assert(false);
  39 |     |         }
  40 |     |     }
  41 |     | 
  42 |     |     /// @notice int256 version of assertEq
  43 |     |     function assertEq(int256 a, int256 b, string memory reason) internal {
  44 |     |         if (a != b) {
  45 |     |             string memory aStr = PropertiesLibString.toString(a);
  46 |     |             string memory bStr = PropertiesLibString.toString(b);
  47 |     |             bytes memory assertMsg = abi.encodePacked(
  48 |     |                 "Invalid: ",
  49 |     |                 aStr,
  50 |     |                 "!=",
  51 |     |                 bStr,
  52 |     |                 ", reason: ",
  53 |     |                 reason
  54 |     |             );
  55 |     |             emit AssertEqFail(string(assertMsg));
  56 |     |             assert(false);
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
  61 |     |     function assertNeq(uint256 a, uint256 b, string memory reason) internal {
  62 |     |         if (a == b) {
  63 |     |             string memory aStr = PropertiesLibString.toString(a);
  64 |     |             string memory bStr = PropertiesLibString.toString(b);
  65 |     |             bytes memory assertMsg = abi.encodePacked(
  66 |     |                 "Invalid: ",
  67 |     |                 aStr,
  68 |     |                 "==",
  69 |     |                 bStr,
  70 |     |                 ", reason: ",
  71 |     |                 reason
  72 |     |             );
  73 |     |             emit AssertNeqFail(string(assertMsg));
  74 |     |             assert(false);
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /// @notice int256 version of assertNeq
  79 |     |     function assertNeq(int256 a, int256 b, string memory reason) internal {
  80 |     |         if (a == b) {
  81 |     |             string memory aStr = PropertiesLibString.toString(a);
  82 |     |             string memory bStr = PropertiesLibString.toString(b);
  83 |     |             bytes memory assertMsg = abi.encodePacked(
  84 |     |                 "Invalid: ",
  85 |     |                 aStr,
  86 |     |                 "==",
  87 |     |                 bStr,
  88 |     |                 ", reason: ",
  89 |     |                 reason
  90 |     |             );
  91 |     |             emit AssertNeqFail(string(assertMsg));
  92 |     |             assert(false);
  93 |     |         }
  94 |     |     }
  95 |     | 
  96 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
  97 |     |     function assertGte(uint256 a, uint256 b, string memory reason) internal {
  98 |     |         if (!(a >= b)) {
  99 |     |             string memory aStr = PropertiesLibString.toString(a);
 100 |     |             string memory bStr = PropertiesLibString.toString(b);
 101 |     |             bytes memory assertMsg = abi.encodePacked(
 102 |     |                 "Invalid: ",
 103 |     |                 aStr,
 104 |     |                 "<",
 105 |     |                 bStr,
 106 |     |                 " failed, reason: ",
 107 |     |                 reason
 108 |     |             );
 109 |     |             emit AssertGteFail(string(assertMsg));
 110 |     |             assert(false);
 111 |     |         }
 112 |     |     }
 113 |     | 
 114 |     |     /// @notice int256 version of assertGte
 115 |     |     function assertGte(int256 a, int256 b, string memory reason) internal {
 116 |     |         if (!(a >= b)) {
 117 |     |             string memory aStr = PropertiesLibString.toString(a);
 118 |     |             string memory bStr = PropertiesLibString.toString(b);
 119 |     |             bytes memory assertMsg = abi.encodePacked(
 120 |     |                 "Invalid: ",
 121 |     |                 aStr,
 122 |     |                 "<",
 123 |     |                 bStr,
 124 |     |                 " failed, reason: ",
 125 |     |                 reason
 126 |     |             );
 127 |     |             emit AssertGteFail(string(assertMsg));
 128 |     |             assert(false);
 129 |     |         }
 130 |     |     }
 131 |     | 
 132 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 133 | *   |     function assertGt(uint256 a, uint256 b, string memory reason) internal {
 134 | *   |         if (!(a > b)) {
 135 |     |             string memory aStr = PropertiesLibString.toString(a);
 136 |     |             string memory bStr = PropertiesLibString.toString(b);
 137 |     |             bytes memory assertMsg = abi.encodePacked(
 138 |     |                 "Invalid: ",
 139 |     |                 aStr,
 140 |     |                 "<=",
 141 |     |                 bStr,
 142 |     |                 " failed, reason: ",
 143 |     |                 reason
 144 |     |             );
 145 |     |             emit AssertGtFail(string(assertMsg));
 146 |     |             assert(false);
 147 |     |         }
 148 |     |     }
 149 |     | 
 150 |     |     /// @notice int256 version of assertGt
 151 |     |     function assertGt(int256 a, int256 b, string memory reason) internal {
 152 |     |         if (!(a > b)) {
 153 |     |             string memory aStr = PropertiesLibString.toString(a);
 154 |     |             string memory bStr = PropertiesLibString.toString(b);
 155 |     |             bytes memory assertMsg = abi.encodePacked(
 156 |     |                 "Invalid: ",
 157 |     |                 aStr,
 158 |     |                 "<=",
 159 |     |                 bStr,
 160 |     |                 " failed, reason: ",
 161 |     |                 reason
 162 |     |             );
 163 |     |             emit AssertGtFail(string(assertMsg));
 164 |     |             assert(false);
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 169 |     |     function assertLte(uint256 a, uint256 b, string memory reason) internal {
 170 |     |         if (!(a <= b)) {
 171 |     |             string memory aStr = PropertiesLibString.toString(a);
 172 |     |             string memory bStr = PropertiesLibString.toString(b);
 173 |     |             bytes memory assertMsg = abi.encodePacked(
 174 |     |                 "Invalid: ",
 175 |     |                 aStr,
 176 |     |                 ">",
 177 |     |                 bStr,
 178 |     |                 " failed, reason: ",
 179 |     |                 reason
 180 |     |             );
 181 |     |             emit AssertLteFail(string(assertMsg));
 182 |     |             assert(false);
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /// @notice int256 version of assertLte
 187 |     |     function assertLte(int256 a, int256 b, string memory reason) internal {
 188 |     |         if (!(a <= b)) {
 189 |     |             string memory aStr = PropertiesLibString.toString(a);
 190 |     |             string memory bStr = PropertiesLibString.toString(b);
 191 |     |             bytes memory assertMsg = abi.encodePacked(
 192 |     |                 "Invalid: ",
 193 |     |                 aStr,
 194 |     |                 ">",
 195 |     |                 bStr,
 196 |     |                 " failed, reason: ",
 197 |     |                 reason
 198 |     |             );
 199 |     |             emit AssertLteFail(string(assertMsg));
 200 |     |             assert(false);
 201 |     |         }
 202 |     |     }
 203 |     | 
 204 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 205 | *   |     function assertLt(uint256 a, uint256 b, string memory reason) internal {
 206 | *   |         if (!(a < b)) {
 207 |     |             string memory aStr = PropertiesLibString.toString(a);
 208 |     |             string memory bStr = PropertiesLibString.toString(b);
 209 |     |             bytes memory assertMsg = abi.encodePacked(
 210 |     |                 "Invalid: ",
 211 |     |                 aStr,
 212 |     |                 ">=",
 213 |     |                 bStr,
 214 |     |                 " failed, reason: ",
 215 |     |                 reason
 216 |     |             );
 217 |     |             emit AssertLtFail(string(assertMsg));
 218 |     |             assert(false);
 219 |     |         }
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice int256 version of assertLt
 223 |     |     function assertLt(int256 a, int256 b, string memory reason) internal {
 224 |     |         if (!(a < b)) {
 225 |     |             string memory aStr = PropertiesLibString.toString(a);
 226 |     |             string memory bStr = PropertiesLibString.toString(b);
 227 |     |             bytes memory assertMsg = abi.encodePacked(
 228 |     |                 "Invalid: ",
 229 |     |                 aStr,
 230 |     |                 ">=",
 231 |     |                 bStr,
 232 |     |                 " failed, reason: ",
 233 |     |                 reason
 234 |     |             );
 235 |     |             emit AssertLtFail(string(assertMsg));
 236 |     |             assert(false);
 237 |     |         }
 238 |     |     }
 239 |     | 
 240 |     |     /// @notice Clamps value to be between low and high, both inclusive
 241 | *   |     function clampBetween(
 242 |     |         uint256 value,
 243 |     |         uint256 low,
 244 |     |         uint256 high
 245 | *   |     ) internal returns (uint256) {
 246 | *   |         if (value < low || value > high) {
 247 | *   |             uint ans = low + (value % (high - low + 1));
 248 | *   |             string memory valueStr = PropertiesLibString.toString(value);
 249 | *   |             string memory ansStr = PropertiesLibString.toString(ans);
 250 | *   |             bytes memory message = abi.encodePacked(
 251 |     |                 "Clamping value ",
 252 | *   |                 valueStr,
 253 |     |                 " to ",
 254 | *   |                 ansStr
 255 |     |             );
 256 | *   |             emit LogString(string(message));
 257 | *   |             return ans;
 258 |     |         }
 259 | *   |         return value;
 260 |     |     }
 261 |     | 
 262 |     |     /// @notice int256 version of clampBetween
 263 |     |     function clampBetween(
 264 |     |         int256 value,
 265 |     |         int256 low,
 266 |     |         int256 high
 267 |     |     ) internal returns (int256) {
 268 |     |         if (value < low || value > high) {
 269 |     |             int range = high - low + 1;
 270 |     |             int clamped = (value - low) % (range);
 271 |     |             if (clamped < 0) clamped += range;
 272 |     |             int ans = low + clamped;
 273 |     |             string memory valueStr = PropertiesLibString.toString(value);
 274 |     |             string memory ansStr = PropertiesLibString.toString(ans);
 275 |     |             bytes memory message = abi.encodePacked(
 276 |     |                 "Clamping value ",
 277 |     |                 valueStr,
 278 |     |                 " to ",
 279 |     |                 ansStr
 280 |     |             );
 281 |     |             emit LogString(string(message));
 282 |     |             return ans;
 283 |     |         }
 284 |     |         return value;
 285 |     |     }
 286 |     | 
 287 |     |     /// @notice clamps a to be less than b
 288 |     |     function clampLt(uint256 a, uint256 b) internal returns (uint256) {
 289 |     |         if (!(a < b)) {
 290 |     |             assertNeq(
 291 |     |                 b,
 292 |     |                 0,
 293 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 294 |     |             );
 295 |     |             uint256 value = a % b;
 296 |     |             string memory aStr = PropertiesLibString.toString(a);
 297 |     |             string memory valueStr = PropertiesLibString.toString(value);
 298 |     |             bytes memory message = abi.encodePacked(
 299 |     |                 "Clamping value ",
 300 |     |                 aStr,
 301 |     |                 " to ",
 302 |     |                 valueStr
 303 |     |             );
 304 |     |             emit LogString(string(message));
 305 |     |             return value;
 306 |     |         }
 307 |     |         return a;
 308 |     |     }
 309 |     | 
 310 |     |     /// @notice int256 version of clampLt
 311 |     |     function clampLt(int256 a, int256 b) internal returns (int256) {
 312 |     |         if (!(a < b)) {
 313 |     |             int256 value = b - 1;
 314 |     |             string memory aStr = PropertiesLibString.toString(a);
 315 |     |             string memory valueStr = PropertiesLibString.toString(value);
 316 |     |             bytes memory message = abi.encodePacked(
 317 |     |                 "Clamping value ",
 318 |     |                 aStr,
 319 |     |                 " to ",
 320 |     |                 valueStr
 321 |     |             );
 322 |     |             emit LogString(string(message));
 323 |     |             return value;
 324 |     |         }
 325 |     |         return a;
 326 |     |     }
 327 |     | 
 328 |     |     /// @notice clamps a to be less than or equal to b
 329 |     |     function clampLte(uint256 a, uint256 b) internal returns (uint256) {
 330 |     |         if (!(a <= b)) {
 331 |     |             uint256 value = a % (b + 1);
 332 |     |             string memory aStr = PropertiesLibString.toString(a);
 333 |     |             string memory valueStr = PropertiesLibString.toString(value);
 334 |     |             bytes memory message = abi.encodePacked(
 335 |     |                 "Clamping value ",
 336 |     |                 aStr,
 337 |     |                 " to ",
 338 |     |                 valueStr
 339 |     |             );
 340 |     |             emit LogString(string(message));
 341 |     |             return value;
 342 |     |         }
 343 |     |         return a;
 344 |     |     }
 345 |     | 
 346 |     |     /// @notice int256 version of clampLte
 347 |     |     function clampLte(int256 a, int256 b) internal returns (int256) {
 348 |     |         if (!(a <= b)) {
 349 |     |             int256 value = b;
 350 |     |             string memory aStr = PropertiesLibString.toString(a);
 351 |     |             string memory valueStr = PropertiesLibString.toString(value);
 352 |     |             bytes memory message = abi.encodePacked(
 353 |     |                 "Clamping value ",
 354 |     |                 aStr,
 355 |     |                 " to ",
 356 |     |                 valueStr
 357 |     |             );
 358 |     |             emit LogString(string(message));
 359 |     |             return value;
 360 |     |         }
 361 |     |         return a;
 362 |     |     }
 363 |     | 
 364 |     |     /// @notice clamps a to be greater than b
 365 |     |     function clampGt(uint256 a, uint256 b) internal returns (uint256) {
 366 |     |         if (!(a > b)) {
 367 |     |             assertNeq(
 368 |     |                 b,
 369 |     |                 type(uint256).max,
 370 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 371 |     |             );
 372 |     |             uint256 value = b + 1;
 373 |     |             string memory aStr = PropertiesLibString.toString(a);
 374 |     |             string memory valueStr = PropertiesLibString.toString(value);
 375 |     |             bytes memory message = abi.encodePacked(
 376 |     |                 "Clamping value ",
 377 |     |                 aStr,
 378 |     |                 " to ",
 379 |     |                 valueStr
 380 |     |             );
 381 |     |             emit LogString(string(message));
 382 |     |             return value;
 383 |     |         } else {
 384 |     |             return a;
 385 |     |         }
 386 |     |     }
 387 |     | 
 388 |     |     /// @notice int256 version of clampGt
 389 |     |     function clampGt(int256 a, int256 b) internal returns (int256) {
 390 |     |         if (!(a > b)) {
 391 |     |             int256 value = b + 1;
 392 |     |             string memory aStr = PropertiesLibString.toString(a);
 393 |     |             string memory valueStr = PropertiesLibString.toString(value);
 394 |     |             bytes memory message = abi.encodePacked(
 395 |     |                 "Clamping value ",
 396 |     |                 aStr,
 397 |     |                 " to ",
 398 |     |                 valueStr
 399 |     |             );
 400 |     |             emit LogString(string(message));
 401 |     |             return value;
 402 |     |         } else {
 403 |     |             return a;
 404 |     |         }
 405 |     |     }
 406 |     | 
 407 |     |     /// @notice clamps a to be greater than or equal to b
 408 |     |     function clampGte(uint256 a, uint256 b) internal returns (uint256) {
 409 |     |         if (!(a > b)) {
 410 |     |             uint256 value = b;
 411 |     |             string memory aStr = PropertiesLibString.toString(a);
 412 |     |             string memory valueStr = PropertiesLibString.toString(value);
 413 |     |             bytes memory message = abi.encodePacked(
 414 |     |                 "Clamping value ",
 415 |     |                 aStr,
 416 |     |                 " to ",
 417 |     |                 valueStr
 418 |     |             );
 419 |     |             emit LogString(string(message));
 420 |     |             return value;
 421 |     |         }
 422 |     |         return a;
 423 |     |     }
 424 |     | 
 425 |     |     /// @notice int256 version of clampGte
 426 |     |     function clampGte(int256 a, int256 b) internal returns (int256) {
 427 |     |         if (!(a > b)) {
 428 |     |             int256 value = b;
 429 |     |             string memory aStr = PropertiesLibString.toString(a);
 430 |     |             string memory valueStr = PropertiesLibString.toString(value);
 431 |     |             bytes memory message = abi.encodePacked(
 432 |     |                 "Clamping value ",
 433 |     |                 aStr,
 434 |     |                 " to ",
 435 |     |                 valueStr
 436 |     |             );
 437 |     |             emit LogString(string(message));
 438 |     |             return value;
 439 |     |         }
 440 |     |         return a;
 441 |     |     }
 442 |     | }
 443 |     | 
 444 |     | /// @notice Efficient library for creating string representations of integers.
 445 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
 446 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
 447 |     | /// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString
 448 |     | library PropertiesLibString {
 449 |     |     function toString(int256 value) internal pure returns (string memory str) {
 450 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
 451 |     |         str = toString(absValue);
 452 |     | 
 453 |     |         if (value < 0) {
 454 |     |             str = string(abi.encodePacked("-", str));
 455 |     |         }
 456 |     |     }
 457 |     | 
 458 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
 459 |     |         /// @solidity memory-safe-assembly
 460 | *   |         assembly {
 461 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
 462 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
 463 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
 464 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
 465 |     | 
 466 |     |             // Update the free memory pointer to avoid overriding our string.
 467 | *   |             mstore(0x40, newFreeMemoryPointer)
 468 |     | 
 469 |     |             // Assign str to the end of the zone of newly allocated memory.
 470 | *   |             str := sub(newFreeMemoryPointer, 32)
 471 |     | 
 472 |     |             // Clean the last word of memory it may not be overwritten.
 473 | *   |             mstore(str, 0)
 474 |     | 
 475 |     |             // Cache the end of the memory to calculate the length later.
 476 | *   |             let end := str
 477 |     | 
 478 |     |             // We write the string from rightmost digit to leftmost digit.
 479 |     |             // The following is essentially a do-while loop that also handles the zero case.
 480 |     |             // prettier-ignore
 481 | *   |             for { let temp := value } 1 {} {
 482 |     |                 // Move the pointer 1 byte to the left.
 483 | *   |                 str := sub(str, 1)
 484 |     | 
 485 |     |                 // Write the character to the pointer.
 486 |     |                 // The ASCII index of the '0' character is 48.
 487 | *   |                 mstore8(str, add(48, mod(temp, 10)))
 488 |     | 
 489 |     |                 // Keep dividing temp until zero.
 490 | *   |                 temp := div(temp, 10)
 491 |     | 
 492 |     |                  // prettier-ignore
 493 | *   |                 if iszero(temp) { break }
 494 |     |             }
 495 |     | 
 496 |     |             // Compute and cache the final total length of the string.
 497 | *   |             let length := sub(end, str)
 498 |     | 
 499 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
 500 | *   |             str := sub(str, 32)
 501 |     | 
 502 |     |             // Store the string's length at the start of memory allocated for our string.
 503 | *   |             mstore(str, length)
 504 |     |         }
 505 |     |     }
 506 |     | 
 507 |     |     function toString(address value) internal pure returns (string memory str) {
 508 |     |         bytes memory s = new bytes(40);
 509 |     |         for (uint i = 0; i < 20; i++) {
 510 |     |             bytes1 b = bytes1(
 511 |     |                 uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))
 512 |     |             );
 513 |     |             bytes1 hi = bytes1(uint8(b) / 16);
 514 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
 515 |     |             s[2 * i] = char(hi);
 516 |     |             s[2 * i + 1] = char(lo);
 517 |     |         }
 518 |     |         return string(s);
 519 |     |     }
 520 |     | 
 521 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
 522 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
 523 |     |         else return bytes1(uint8(b) + 0x57);
 524 |     |     }
 525 |     | }
 526 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/src/Staker.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   6 |     | import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
   7 |     | import "@openzeppelin/contracts/utils/Pausable.sol";
   8 |     | import "@openzeppelin/contracts/access/AccessControl.sol";
   9 |     | 
  10 | *   | contract Staker is AccessControl, ReentrancyGuard, Pausable {
  11 |     |     using SafeERC20 for IERC20;
  12 |     | 
  13 | *   |     bytes32 public constant REWARDS_ADMIN_ROLE = keccak256("REWARDS_ADMIN_ROLE");
  14 | *   |     bytes32 public constant PAUSE_GUARDIAN_ROLE = keccak256("PAUSE_GUARDIAN_ROLE");
  15 |     | 
  16 |     |     // Events
  17 |     |     event Staked(address indexed user, uint256 amount);
  18 |     |     event Withdrawn(address indexed user, uint256 amount);
  19 |     |     event RewardAdded(address indexed token, uint256 amount, uint256 duration);
  20 |     |     event RewardClaimed(address indexed user, address indexed token, uint256 amount);
  21 |     |     event RewardTokenRemoved(address indexed token);
  22 |     | 
  23 | *   |     IERC20 public immutable stakingToken;
  24 |     |     IERC20[] public rewardTokens;
  25 | *   |     mapping(address => bool) public isRewardToken;
  26 |     | 
  27 |     |     struct Reward {
  28 |     |         uint256 duration;
  29 |     |         uint256 rate;
  30 |     |         uint256 lastUpdateTime;
  31 |     |         uint256 rewardPerTokenStored;
  32 |     |     }
  33 |     | 
  34 | *   |     mapping(address => Reward) public rewards;
  35 |     |     mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;
  36 |     |     mapping(address => mapping(address => uint256)) public rewardsEarned;
  37 |     | 
  38 |     |     uint256 private _totalStaked;
  39 |     |     mapping(address => uint256) private _stakedBalances;
  40 |     | 
  41 | *   |     uint256 private constant MAX_REWARD_DURATION = 3650 days; 
  42 |     | 
  43 | *   |     constructor(address _stakingToken, address _admin, address _pauseGuardian) {
  44 | *   |         require(_stakingToken != address(0), "Invalid staking token");
  45 | *   |         require(_admin != address(0), "Invalid admin address");
  46 | *   |         require(_pauseGuardian != address(0), "Invalid pause guardian");
  47 |     | 
  48 | *   |         stakingToken = IERC20(_stakingToken);
  49 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, _admin);
  50 | *   |         _grantRole(REWARDS_ADMIN_ROLE, _admin);
  51 | *   |         _grantRole(PAUSE_GUARDIAN_ROLE, _pauseGuardian);
  52 |     |     }
  53 |     | 
  54 | *   |     function stake(
  55 |     |         uint256 amount
  56 |     |     ) external nonReentrant whenNotPaused {
  57 | *   |         require(amount > 0, "Cannot stake 0");
  58 | *   |         _updateRewards(msg.sender);
  59 |     | 
  60 | *   |         _totalStaked += amount;
  61 | *   |         _stakedBalances[msg.sender] += amount;
  62 |     | 
  63 | *   |         stakingToken.safeTransferFrom(msg.sender, address(this), amount);
  64 | *   |         emit Staked(msg.sender, amount);
  65 |     |     }
  66 |     | 
  67 | *   |     function withdraw(
  68 |     |         uint256 amount
  69 |     |     ) external nonReentrant whenNotPaused {
  70 | *   |         require(amount > 0, "Cannot withdraw 0");
  71 | *   |         require(_stakedBalances[msg.sender] >= amount, "Insufficient balance");
  72 | *   |         _updateRewards(msg.sender);
  73 |     | 
  74 | *   |         _totalStaked -= amount;
  75 | *   |         _stakedBalances[msg.sender] -= amount;
  76 |     | 
  77 | *   |         stakingToken.safeTransfer(msg.sender, amount);
  78 | *   |         emit Withdrawn(msg.sender, amount);
  79 |     |     }
  80 |     | 
  81 | *   |     function claimRewards(
  82 |     |         address rewardToken
  83 | *   |     ) external nonReentrant {
  84 | *   |         require(rewards[rewardToken].duration > 0, "Invalid reward token");
  85 | *   |         _updateRewards(msg.sender);
  86 |     | 
  87 | *   |         uint256 reward = rewardsEarned[msg.sender][rewardToken];
  88 | *   |         require(reward > 0, "No rewards to claim");
  89 |     | 
  90 | *   |         rewardsEarned[msg.sender][rewardToken] = 0;
  91 | *   |         IERC20(rewardToken).safeTransfer(msg.sender, reward);
  92 | *   |         emit RewardClaimed(msg.sender, rewardToken, reward);
  93 |     |     }
  94 |     | 
  95 | *   |     function addReward(
  96 |     |         address rewardToken,
  97 |     |         uint256 totalRewards,
  98 |     |         uint256 duration
  99 | *   |     ) external onlyRole(REWARDS_ADMIN_ROLE) {
 100 | *   |         require(rewardToken != address(0), "Invalid reward token");
 101 | *   |         require(totalRewards > 0 && duration > 0, "Invalid parameters");
 102 | *   |         require(duration <= MAX_REWARD_DURATION, "Duration exceeds maximum");
 103 |     | 
 104 | *   |         Reward storage reward = rewards[rewardToken];
 105 | *   |         if (reward.duration > 0) {
 106 | *   |             require(block.timestamp >= reward.lastUpdateTime + reward.duration, "Previous reward ongoing");
 107 | *   |             uint256 endTime = reward.lastUpdateTime + reward.duration;
 108 | *   |             uint256 timeElapsed = endTime - reward.lastUpdateTime;
 109 | *   |             if (_totalStaked > 0) {
 110 | *   |                 reward.rewardPerTokenStored += (timeElapsed * reward.rate * 1e18) / _totalStaked;
 111 |     |             }
 112 | *   |             reward.lastUpdateTime = endTime;
 113 |     |         }
 114 |     | 
 115 | *   |         uint256 currentBalance = IERC20(rewardToken).balanceOf(address(this));
 116 | *   |         require(totalRewards >= currentBalance, "Insufficient new rewards");
 117 | *   |         uint256 amountToTransfer = totalRewards - currentBalance;
 118 |     | 
 119 | *   |         if (!isRewardToken[rewardToken]) {
 120 | *   |             rewardTokens.push(IERC20(rewardToken));
 121 | *   |             isRewardToken[rewardToken] = true;
 122 |     |         }
 123 |     | 
 124 | *   |         uint256 rate = totalRewards / duration;
 125 | *   |         reward.duration = duration;
 126 | *   |         reward.rate = rate;
 127 | *   |         reward.lastUpdateTime = block.timestamp;
 128 |     | 
 129 | *   |         if (amountToTransfer > 0) {
 130 | *   |             IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amountToTransfer);
 131 |     |         }
 132 | *   |         emit RewardAdded(rewardToken, totalRewards, duration);
 133 |     |     }
 134 |     | 
 135 |     |     function removeRewardToken(
 136 |     |         address rewardToken
 137 |     |     ) external onlyRole(REWARDS_ADMIN_ROLE) {
 138 |     |         require(isRewardToken[rewardToken], "Not a reward token");
 139 |     |         require(
 140 |     |             block.timestamp >= rewards[rewardToken].lastUpdateTime + rewards[rewardToken].duration, "Reward ongoing"
 141 |     |         );
 142 |     | 
 143 |     |         isRewardToken[rewardToken] = false;
 144 |     | 
 145 |     |         for (uint256 i = 0; i < rewardTokens.length; i++) {
 146 |     |             if (address(rewardTokens[i]) == rewardToken) {
 147 |     |                 rewardTokens[i] = rewardTokens[rewardTokens.length - 1];
 148 |     |                 rewardTokens.pop();
 149 |     |                 break;
 150 |     |             }
 151 |     |         }
 152 |     |         emit RewardTokenRemoved(rewardToken);
 153 |     |     }
 154 |     | 
 155 | *   |     function _updateRewards(
 156 |     |         address user
 157 |     |     ) internal {
 158 | *   |         for (uint256 i = 0; i < rewardTokens.length; i++) {
 159 | *   |             address token = address(rewardTokens[i]);
 160 | *   |             if (!isRewardToken[token]) continue;
 161 |     | 
 162 | *   |             Reward storage reward = rewards[token];
 163 | *   |             reward.rewardPerTokenStored = _rewardPerToken(token);
 164 | *   |             reward.lastUpdateTime = lastTimeRewardApplicable(token);
 165 |     | 
 166 | *   |             if (user != address(0)) {
 167 | *   |                 rewardsEarned[user][token] = earned(user, token);
 168 | *   |                 userRewardPerTokenPaid[user][token] = reward.rewardPerTokenStored;
 169 |     |             }
 170 |     |         }
 171 |     |     }
 172 |     | 
 173 | *   |     function lastTimeRewardApplicable(
 174 |     |         address rewardToken
 175 | *   |     ) public view returns (uint256) {
 176 | *   |         Reward storage reward = rewards[rewardToken];
 177 | *   |         return block.timestamp < reward.lastUpdateTime + reward.duration
 178 | *   |             ? block.timestamp
 179 | *   |             : reward.lastUpdateTime + reward.duration;
 180 |     |     }
 181 |     | 
 182 | *   |     function _rewardPerToken(
 183 |     |         address rewardToken
 184 | *   |     ) internal view returns (uint256) {
 185 | *   |         Reward storage reward = rewards[rewardToken];
 186 | *   |         if (_totalStaked == 0) return reward.rewardPerTokenStored;
 187 |     | 
 188 | *   |         uint256 timeElapsed = lastTimeRewardApplicable(rewardToken) - reward.lastUpdateTime;
 189 | *   |         return reward.rewardPerTokenStored + (timeElapsed * reward.rate * 1e18) / _totalStaked;
 190 |     |     }
 191 |     | 
 192 | *   |     function earned(address user, address rewardToken) public view returns (uint256) {
 193 | *   |         uint256 currentRewardPerToken = _rewardPerToken(rewardToken);
 194 | *   |         uint256 paid = userRewardPerTokenPaid[user][rewardToken];
 195 | *   |         if (currentRewardPerToken < paid) return rewardsEarned[user][rewardToken];
 196 |     | 
 197 | *   |         uint256 delta = currentRewardPerToken - paid;
 198 | *   |         uint256 newRewards = (_stakedBalances[user] * delta) / 1e18;
 199 | *   |         return newRewards + rewardsEarned[user][rewardToken];
 200 |     |     }
 201 |     | 
 202 | *   |     function totalStaked() external view returns (uint256) {
 203 | *   |         return _totalStaked;
 204 |     |     }
 205 |     | 
 206 | *   |     function stakedBalanceOf(
 207 |     |         address user
 208 | *   |     ) external view returns (uint256) {
 209 | *   |         return _stakedBalances[user];
 210 |     |     }
 211 |     | 
 212 | *   |     function claimAllRewards() external nonReentrant {
 213 | *   |         _updateRewards(msg.sender);
 214 |     | 
 215 | *   |         for (uint256 i = 0; i < rewardTokens.length; i++) {
 216 | *   |             address token = address(rewardTokens[i]);
 217 | *   |             uint256 reward = rewardsEarned[msg.sender][token];
 218 | *   |             if (reward > 0) {
 219 | *   |                 rewardsEarned[msg.sender][token] = 0;
 220 | *   |                 IERC20(token).safeTransfer(msg.sender, reward);
 221 | *   |                 emit RewardClaimed(msg.sender, token, reward);
 222 |     |             }
 223 |     |         }
 224 |     |     }
 225 |     | }
 226 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/test/EchidnaTesting/E2E.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {PropertiesAsserts} from "properties/util/PropertiesHelper.sol";
   5 |     | import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
   6 |     | 
   7 |     | import {TestERC20Token} from "properties/ERC4626/util/TestERC20Token.sol";
   8 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   9 |     | import {Staker} from "../../src/Staker.sol";
  10 |     | import {IHevm} from "properties/util/Hevm.sol";
  11 |     | 
  12 |     | /*
  13 |     | SOLC_VERSION=0.8.20 echidna ./test/EchidnaTesting/E2E.sol \
  14 |     |   --contract E2E \
  15 |     |   --config ./test/EchidnaTesting/echidna.yaml \
  16 |     |   --workers 10
  17 |     |  */
  18 |     | 
  19 | *   | contract StakerActor {
  20 |     |     Staker public immutable staker;
  21 |     |     IERC20 public immutable stakingToken;
  22 |     | 
  23 | *   |     constructor(
  24 |     |         Staker _staker
  25 |     |     ) {
  26 | *   |         staker = _staker;
  27 | *   |         stakingToken = IERC20(staker.stakingToken());
  28 | *   |         stakingToken.approve(address(staker), type(uint256).max);
  29 |     |     }
  30 |     | 
  31 | *   |     function stake(
  32 |     |         uint256 amount
  33 |     |     ) external {
  34 | *   |         staker.stake(amount);
  35 |     |     }
  36 |     | 
  37 | *   |     function withdraw(
  38 |     |         uint256 amount
  39 |     |     ) external {
  40 | *   |         staker.withdraw(amount);
  41 |     |     }
  42 |     | 
  43 | *   |     function claimRewards(
  44 |     |         address rewardToken
  45 |     |     ) external {
  46 | *   |         staker.claimRewards(rewardToken);
  47 |     |     }
  48 |     | 
  49 | *   |     function claimAllRewards() external {
  50 | *   |         staker.claimAllRewards();
  51 |     |     }
  52 |     | }
  53 |     | 
  54 | *r  | contract E2E is PropertiesAsserts {
  55 |     |     using Strings for uint256;
  56 |     | 
  57 | *   |     IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
  58 |     | 
  59 |     |     Staker public staker;
  60 |     |     TestERC20Token public stakingToken;
  61 |     |     TestERC20Token public rewardToken1;
  62 |     |     TestERC20Token public rewardToken2;
  63 |     | 
  64 | *   |     address constant ADMIN = address(0x1001);
  65 | *   |     address constant PAUSE_GUARDIAN = address(0x1002);
  66 | *   |     uint256 constant INITIAL_BALANCE = 1000 ether;
  67 |     | 
  68 |     |     StakerActor[] public actors;
  69 | *   |     uint256 public constant START_TIMESTAMP = 1_706_745_600;
  70 | *   |     uint256 public constant START_BLOCK = 17_336_000;
  71 |     | 
  72 | *   |     constructor() {
  73 | *   |         hevm.warp(START_TIMESTAMP);
  74 | *   |         hevm.roll(START_BLOCK);
  75 |     | 
  76 |     |         // Deploy tokens
  77 | *   |         stakingToken = new TestERC20Token("Staking Token", "STK", 18);
  78 | *   |         rewardToken1 = new TestERC20Token("Reward Token 1", "RWD1", 18);
  79 | *   |         rewardToken2 = new TestERC20Token("Reward Token 2", "RWD2", 18);
  80 |     | 
  81 |     |         // Deploy staker
  82 | *   |         staker = new Staker(address(stakingToken), ADMIN, PAUSE_GUARDIAN);
  83 |     | 
  84 |     |         // Create actors
  85 | *   |         for (uint256 i = 0; i < 3; i++) {
  86 | *   |             actors.push(new StakerActor(staker));
  87 |     |         }
  88 |     | 
  89 |     |         // Fund actors
  90 | *   |         for (uint256 i = 0; i < actors.length; i++) {
  91 | *   |             address actor = address(actors[i]);
  92 | *   |             stakingToken.mint(actor, INITIAL_BALANCE);
  93 | *   |             rewardToken1.mint(actor, INITIAL_BALANCE);
  94 | *   |             rewardToken2.mint(actor, INITIAL_BALANCE);
  95 |     |         }
  96 |     | 
  97 |     |         // Setup rewards
  98 | *   |         rewardToken1.mint(ADMIN, 100_000 ether);
  99 | *   |         rewardToken2.mint(ADMIN, 100_000 ether);
 100 |     | 
 101 | *   |         hevm.prank(ADMIN);
 102 | *   |         rewardToken1.approve(address(staker), type(uint256).max);
 103 |     | 
 104 | *   |         hevm.prank(ADMIN);
 105 | *   |         rewardToken2.approve(address(staker), type(uint256).max);
 106 |     | 
 107 | *   |         hevm.prank(ADMIN);
 108 | *   |         staker.addReward(address(rewardToken1), 1000 ether, 365 days);
 109 |     | 
 110 | *   |         hevm.prank(ADMIN);
 111 | *   |         staker.addReward(address(rewardToken2), 1000 ether, 365 days);
 112 |     |     }
 113 |     | 
 114 |     |     /* ================================================================
 115 |     |                             Echidna invariants
 116 |     |        ================================================================ */
 117 |     |     function echidna_total_staked_matches_sum() public view returns (bool) {
 118 |     |         uint256 sum;
 119 |     |         for (uint256 i = 0; i < actors.length; i++) {
 120 |     |             sum += staker.stakedBalanceOf(address(actors[i]));
 121 |     |         }
 122 |     |         return staker.totalStaked() == sum;
 123 |     |     }
 124 |     | 
 125 |     |     function echidna_staking_token_balance_consistent() public view returns (bool) {
 126 |     |         return stakingToken.balanceOf(address(staker)) == staker.totalStaked();
 127 |     |     }
 128 |     | 
 129 |     |     function echidna_reward_rate_nonzero_during_active_period() public view returns (bool) {
 130 |     |         (uint256 duration1,,,) = staker.rewards(address(rewardToken1));
 131 |     |         (uint256 duration2,,,) = staker.rewards(address(rewardToken2));
 132 |     | 
 133 |     |         return duration1 > 0 && duration2 > 0;
 134 |     |     }
 135 |     | 
 136 |     |     function echidna_no_negative_balances() public view returns (bool) {
 137 |     |         for (uint256 i = 0; i < actors.length; i++) {
 138 |     |             if (staker.stakedBalanceOf(address(actors[i])) > INITIAL_BALANCE) {
 139 |     |                 return false;
 140 |     |             }
 141 |     |         }
 142 |     |         return true;
 143 |     |     }
 144 |     | 
 145 |     |     function echidna_stakingIsConsistent() public view returns (bool success) {
 146 |     |         // Check that the sum of all user staked balances matches totalStaked
 147 |     |         uint256 sum;
 148 |     |         for (uint256 i = 0; i < actors.length; i++) {
 149 |     |             address actor = address(actors[i]);
 150 |     |             sum += staker.stakedBalanceOf(actor);
 151 |     |         }
 152 |     |         if (sum != staker.totalStaked()) return false;
 153 |     | 
 154 |     |         // Optionally, check that reward tokens are registered and earned is non-negative
 155 |     |         for (uint256 i = 0; i < actors.length; i++) {
 156 |     |             address actor = address(actors[i]);
 157 |     |             for (uint256 j = 0; j < 2; j++) {
 158 |     |                 address rewardToken = j == 0 ? address(rewardToken1) : address(rewardToken2);
 159 |     |                 if (!staker.isRewardToken(rewardToken)) return false;
 160 |     |                 // earned should never underflow
 161 |     |                 if (staker.earned(actor, rewardToken) < 0) return false;
 162 |     |             }
 163 |     |         }
 164 |     | 
 165 |     |         return true;
 166 |     |     }
 167 |     | 
 168 |     |     /* ================================================================
 169 |     |                             Functions used for system interaction
 170 |     |        ================================================================ */
 171 | *   |     function stake(uint8 actorIndex, uint256 amount) public {
 172 | *   |         emit LogUint256("[stake] block.timestamp:", block.timestamp);
 173 |     | 
 174 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 175 | *   |         amount = clampBetween(amount, 1, stakingToken.balanceOf(address(actors[actorIndex])));
 176 |     | 
 177 | *   |         uint256 preStaked = staker.stakedBalanceOf(address(actors[actorIndex]));
 178 | *   |         uint256 preTotal = staker.totalStaked();
 179 |     | 
 180 | *   |         actors[actorIndex].stake(amount);
 181 |     | 
 182 | *   |         emit LogString(string.concat("Staked ", amount.toString(), " tokens by actor ", uint256(actorIndex).toString()));
 183 |     | 
 184 | *   |         assertEq(staker.stakedBalanceOf(address(actors[actorIndex])), preStaked + amount, "Staked balance mismatch");
 185 | *   |         assertEq(staker.totalStaked(), preTotal + amount, "Total staked mismatch");
 186 |     |     }
 187 |     | 
 188 | *   |     function withdraw(uint8 actorIndex, uint256 amount) public {
 189 | *   |         emit LogUint256("[withdraw] block.timestamp:", block.timestamp);
 190 |     | 
 191 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 192 | *   |         uint256 userStaked = staker.stakedBalanceOf(address(actors[actorIndex]));
 193 | *   |         amount = clampBetween(amount, 1, userStaked);
 194 |     | 
 195 | *   |         uint256 preStaked = userStaked;
 196 | *   |         uint256 preTotal = staker.totalStaked();
 197 | *   |         uint256 preBalance = stakingToken.balanceOf(address(actors[actorIndex]));
 198 |     | 
 199 | *   |         actors[actorIndex].withdraw(amount);
 200 |     | 
 201 | *   |         emit LogString(
 202 | *   |             string.concat("Withdrew ", amount.toString(), " tokens by actor ", uint256(actorIndex).toString())
 203 |     |         );
 204 |     | 
 205 | *   |         assertEq(staker.stakedBalanceOf(address(actors[actorIndex])), preStaked - amount, "Staked balance mismatch");
 206 | *   |         assertEq(staker.totalStaked(), preTotal - amount, "Total staked mismatch");
 207 | *   |         assertEq(stakingToken.balanceOf(address(actors[actorIndex])), preBalance + amount, "Token balance mismatch");
 208 |     |     }
 209 |     | 
 210 | *   |     function claimRewards(uint8 actorIndex, uint8 tokenIndex) public {
 211 | *   |         emit LogUint256("[claimRewards] block.timestamp:", block.timestamp);
 212 |     | 
 213 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 214 | *   |         tokenIndex = uint8(clampBetween(tokenIndex, 0, 1));
 215 | *   |         address rewardToken = tokenIndex == 0 ? address(rewardToken1) : address(rewardToken2);
 216 |     | 
 217 | *   |         uint256 earned = staker.earned(address(actors[actorIndex]), rewardToken);
 218 | *   |         if (earned == 0) return;
 219 |     | 
 220 | *   |         uint256 preBalance = IERC20(rewardToken).balanceOf(address(actors[actorIndex]));
 221 | *r  |         actors[actorIndex].claimRewards(rewardToken);
 222 |     | 
 223 | *   |         emit LogString(
 224 | *   |             string.concat("Claimed ", earned.toString(), " rewards by actor ", uint256(actorIndex).toString())
 225 |     |         );
 226 |     | 
 227 | *   |         assertEq(
 228 | *   |             IERC20(rewardToken).balanceOf(address(actors[actorIndex])), preBalance + earned, "Reward claim mismatch"
 229 |     |         );
 230 | *   |         assertEq(staker.earned(address(actors[actorIndex]), rewardToken), 0, "Rewards not reset");
 231 |     |     }
 232 |     | 
 233 | *   |     function claimAllRewards(
 234 |     |         uint8 actorIndex
 235 | *   |     ) public {
 236 | *   |         emit LogUint256("[claimAllRewards] block.timestamp:", block.timestamp);
 237 |     | 
 238 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 239 |     | 
 240 | *   |         uint256 earned1 = staker.earned(address(actors[actorIndex]), address(rewardToken1));
 241 | *   |         uint256 earned2 = staker.earned(address(actors[actorIndex]), address(rewardToken2));
 242 | *   |         uint256 preBalance1 = rewardToken1.balanceOf(address(actors[actorIndex]));
 243 | *   |         uint256 preBalance2 = rewardToken2.balanceOf(address(actors[actorIndex]));
 244 |     | 
 245 | *r  |         actors[actorIndex].claimAllRewards();
 246 |     | 
 247 | *   |         emit LogString(string.concat("Claimed all rewards by actor ", uint256(actorIndex).toString()));
 248 |     | 
 249 | *   |         if (earned1 > 0) {
 250 | *   |             assertEq(
 251 | *   |                 rewardToken1.balanceOf(address(actors[actorIndex])), preBalance1 + earned1, "Token1 claim mismatch"
 252 |     |             );
 253 |     |         }
 254 | *   |         if (earned2 > 0) {
 255 | *   |             assertEq(
 256 | *   |                 rewardToken2.balanceOf(address(actors[actorIndex])), preBalance2 + earned2, "Token2 claim mismatch"
 257 |     |             );
 258 |     |         }
 259 |     |     }
 260 |     | 
 261 | *   |     function addReward(uint8 tokenIndex, uint256 totalRewards, uint256 duration) public {
 262 | *   |         emit LogUint256("[addReward] block.timestamp:", block.timestamp);
 263 |     | 
 264 | *   |         tokenIndex = uint8(clampBetween(tokenIndex, 0, 1));
 265 | *   |         address rewardToken = tokenIndex == 0 ? address(rewardToken1) : address(rewardToken2);
 266 | *   |         totalRewards = clampBetween(totalRewards, 1, 1000 ether);
 267 | *   |         duration = clampBetween(duration, 1 days, 365 days);
 268 |     | 
 269 | *   |         hevm.prank(ADMIN);
 270 | *r  |         staker.addReward(rewardToken, totalRewards, duration);
 271 |     | 
 272 | *   |         emit LogString(
 273 | *   |             string.concat(
 274 |     |                 "Added reward: token=",
 275 | *   |                 Strings.toHexString(rewardToken),
 276 |     |                 " amount=",
 277 | *   |                 totalRewards.toString(),
 278 |     |                 " duration=",
 279 | *   |                 duration.toString()
 280 |     |             )
 281 |     |         );
 282 |     | 
 283 | *   |         (uint256 rewardDuration,,,) = staker.rewards(rewardToken);
 284 | *   |         assertEq(rewardDuration, duration, "Duration mismatch");
 285 | *   |         require(staker.isRewardToken(rewardToken), "Token not registered");
 286 |     |     }
 287 |     | 
 288 | *   |     function warp(
 289 |     |         uint256 timeJump
 290 |     |     ) public {
 291 | *   |         timeJump = clampBetween(timeJump, 1 days, 365 days);
 292 | *   |         hevm.warp(block.timestamp + timeJump);
 293 | *   |         emit LogString(string.concat("Warped ", timeJump.toString(), " seconds"));
 294 |     |     }
 295 |     | 
 296 |     |     /* ================================================================
 297 |     |                             Properties:
 298 |     |             checking if max* functions are aligned with ERC4626
 299 |     |        ================================================================ */
 300 | *   |     function maxStake_correctMax(
 301 |     |         uint8 actorIndex
 302 | *   |     ) public {
 303 | *   |         emit LogUint256("[maxStake_correctMax] block.timestamp:", block.timestamp);
 304 |     | 
 305 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 306 | *   |         uint256 maxAmount = stakingToken.balanceOf(address(actors[actorIndex]));
 307 | *r  |         require(maxAmount > 0, "Max stake is zero");
 308 |     | 
 309 | *   |         uint256 preStaked = staker.stakedBalanceOf(address(actors[actorIndex]));
 310 | *   |         uint256 preTotal = staker.totalStaked();
 311 |     | 
 312 | *   |         actors[actorIndex].stake(maxAmount);
 313 |     | 
 314 | *   |         assertEq(staker.stakedBalanceOf(address(actors[actorIndex])), preStaked + maxAmount, "Staked balance mismatch");
 315 | *   |         assertEq(staker.totalStaked(), preTotal + maxAmount, "Total staked mismatch");
 316 |     |     }
 317 |     | 
 318 | *   |     function maxWithdraw_correctMax(
 319 |     |         uint8 actorIndex
 320 | *   |     ) public {
 321 | *   |         emit LogUint256("[maxWithdraw_correctMax] block.timestamp:", block.timestamp);
 322 |     | 
 323 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 324 | *   |         uint256 maxAmount = staker.stakedBalanceOf(address(actors[actorIndex]));
 325 | *r  |         require(maxAmount > 0, "Max withdraw is zero");
 326 |     | 
 327 | *   |         uint256 preStaked = maxAmount;
 328 | *   |         uint256 preTotal = staker.totalStaked();
 329 | *   |         uint256 preBalance = stakingToken.balanceOf(address(actors[actorIndex]));
 330 |     | 
 331 | *   |         actors[actorIndex].withdraw(maxAmount);
 332 |     | 
 333 | *   |         assertEq(staker.stakedBalanceOf(address(actors[actorIndex])), 0, "Staked balance should be zero");
 334 | *   |         assertEq(staker.totalStaked(), preTotal - preStaked, "Total staked mismatch");
 335 | *   |         assertEq(stakingToken.balanceOf(address(actors[actorIndex])), preBalance + preStaked, "Token balance mismatch");
 336 |     |     }
 337 |     | 
 338 | *   |     function maxStake_correctReturnValue(
 339 |     |         uint8 actorIndex
 340 | *   |     ) public {
 341 | *   |         emit LogUint256("[maxStake_correctReturnValue] block.timestamp:", block.timestamp);
 342 |     | 
 343 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 344 | *   |         address actor = address(actors[actorIndex]);
 345 | *   |         uint256 maxStake = stakingToken.balanceOf(actor);
 346 |     | 
 347 | *r  |         require(maxStake != 0, "Zero tokens to stake");
 348 |     | 
 349 | *   |         emit LogString(string.concat("Max tokens to stake: ", maxStake.toString()));
 350 |     | 
 351 |     |         // Try to stake the max amount
 352 | *   |         try actors[actorIndex].stake(maxStake) {
 353 |     |             // check post-conditions here
 354 |     |         } catch {
 355 |     |             assert(false);
 356 |     |         }
 357 |     |     }
 358 |     | 
 359 |     |     /* ================================================================
 360 |     |                             Other properties
 361 |     |        ================================================================ */
 362 |     |     
 363 | *   |     function test_reward_expiration() public {
 364 |     |     // Advance beyond reward period
 365 | *   |     warp(366 days);
 366 |     |     
 367 |     |     // Should not accumulate rewards
 368 | *   |     uint256 earnedBefore = staker.earned(address(actors[0]), address(rewardToken1));
 369 | *   |     warp(1 days);
 370 | *   |     uint256 earnedAfter = staker.earned(address(actors[0]), address(rewardToken1));
 371 |     |     
 372 | *   |     assertEq(earnedAfter, earnedBefore, "Rewards should stop after expiration");
 373 |     |     }
 374 |     |     // Ensure stake never zero
 375 |     |     // This function ensures that the staker's balance never goes to zero
 376 |     |     // by always staking at least 1 token if the actor has a balance.
 377 |     |     // It also checks that the staker's balance increases after staking.
 378 |     |     // If the actor has no balance, it will not attempt to stake.
 379 | *   |     function stakeNeverZero(uint8 actorIndex, uint256 amount) public {
 380 | *   |         emit LogUint256("[stakeNeverZero] block.timestamp:", block.timestamp);
 381 |     | 
 382 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 383 | *   |         amount = clampBetween(amount, 1, stakingToken.balanceOf(address(actors[actorIndex])));
 384 |     | 
 385 | *   |         uint256 preStaked = staker.stakedBalanceOf(address(actors[actorIndex]));
 386 | *   |         actors[actorIndex].stake(amount);
 387 |     | 
 388 | *   |         uint256 postStaked = staker.stakedBalanceOf(address(actors[actorIndex]));
 389 | *   |         assertGt(postStaked, preStaked, "Stake should increase balance");
 390 |     |     }
 391 |     | 
 392 | *   |     function withdrawNeverZero(uint8 actorIndex, uint256 amount) public {
 393 | *   |         emit LogUint256("[withdrawNeverZero] block.timestamp:", block.timestamp);
 394 |     | 
 395 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 396 | *   |         uint256 userStaked = staker.stakedBalanceOf(address(actors[actorIndex]));
 397 | *r  |         require(userStaked > 0, "No staked balance");
 398 |     | 
 399 | *   |         amount = clampBetween(amount, 1, userStaked);
 400 |     | 
 401 | *   |         uint256 preStaked = userStaked;
 402 | *   |         actors[actorIndex].withdraw(amount);
 403 |     | 
 404 | *   |         uint256 postStaked = staker.stakedBalanceOf(address(actors[actorIndex]));
 405 | *   |         assertLt(postStaked, preStaked, "Withdraw should decrease balance");
 406 |     |     }
 407 |     | 
 408 | *   |     function reward_claim_consistency(
 409 |     |         uint8 actorIndex
 410 | *   |     ) public {
 411 | *   |         emit LogUint256("[reward_claim_consistency] block.timestamp:", block.timestamp);
 412 |     | 
 413 | *   |         actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));
 414 | *   |         address actorAddr = address(actors[actorIndex]);
 415 |     | 
 416 | *   |         uint256 earned1Before = staker.earned(actorAddr, address(rewardToken1));
 417 | *   |         uint256 earned2Before = staker.earned(actorAddr, address(rewardToken2));
 418 |     | 
 419 | *r  |         actors[actorIndex].claimAllRewards();
 420 |     | 
 421 | *   |         uint256 earned1After = staker.earned(actorAddr, address(rewardToken1));
 422 | *   |         uint256 earned2After = staker.earned(actorAddr, address(rewardToken2));
 423 |     | 
 424 | *   |         assertEq(earned1After, 0, "Rewards not reset for token1");
 425 | *   |         assertEq(earned2After, 0, "Rewards not reset for token2");
 426 |     | 
 427 | *   |         if (earned1Before > 0 || earned2Before > 0) {
 428 | *   |             emit LogString(
 429 | *   |                 string.concat("Claimed rewards: ", earned1Before.toString(), " + ", earned2Before.toString())
 430 |     |             );
 431 |     |         }
 432 |     |     }
 433 |     | 
 434 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
 435 |     |     /*                        ERC20 PROPERTIES                    */
 436 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
 437 |     | 
 438 |     |     // Total supply should only change by mint or burn
 439 |     |     function test_ERC20_constantSupply() public view returns (bool) {
 440 |     |         // If token is mintable/burnable, skip this property
 441 |     |         uint256 expectedSupply = 1000 ether * actors.length + 200_000 ether; // initial actor + admin mints
 442 |     |         return stakingToken.totalSupply() == expectedSupply;
 443 |     |     }
 444 |     | 
 445 |     |     // User balance must not exceed total supply
 446 |     |     function test_ERC20_userBalanceNotExceedSupply() public view returns (bool) {
 447 |     |         for (uint256 i = 0; i < actors.length; i++) {
 448 |     |             if (stakingToken.balanceOf(address(actors[i])) > stakingToken.totalSupply()) {
 449 |     |                 return false;
 450 |     |             }
 451 |     |         }
 452 |     |         return true;
 453 |     |     }
 454 |     | 
 455 |     |     // No negative balances (redundant in Solidity, but for completeness)
 456 |     |     function test_ERC20_noNegativeBalances() public view returns (bool) {
 457 |     |         for (uint256 i = 0; i < actors.length; i++) {
 458 |     |             if (stakingToken.balanceOf(address(actors[i])) < 0) {
 459 |     |                 return false;
 460 |     |             }
 461 |     |         }
 462 |     |         return true;
 463 |     |     }
 464 |     | 
 465 |     |     // Sum of all balances <= total supply
 466 |     |     function echidna_ERC20_sumBalancesNotExceedSupply() public view returns (bool) {
 467 |     |         uint256 sum;
 468 |     |         for (uint256 i = 0; i < actors.length; i++) {
 469 |     |             sum += stakingToken.balanceOf(address(actors[i]));
 470 |     |         }
 471 |     | 
 472 |     |         sum += stakingToken.balanceOf(address(staker));
 473 |     |         return sum <= stakingToken.totalSupply();
 474 |     |     }
 475 |     | 
 476 |     |     // Address zero should have zero balance
 477 | *   |     function test_ERC20external_zeroAddressBalance() public {
 478 | *   |         assertEq(stakingToken.balanceOf(address(0)), 0, "Address zero balance not equal to zero");
 479 |     |     }
 480 |     | 
 481 |     |     // Transfers to zero address should not be allowed
 482 |     |     function echidna_ERC20external_transferToZeroAddress() public returns (bool) {
 483 |     |         if (stakingToken.totalSupply() == 0) return true;
 484 |     | 
 485 |     |         uint256 balance = stakingToken.balanceOf(address(this));
 486 |     |         if (balance == 0) return true;
 487 |     | 
 488 |     |         try stakingToken.transfer(address(0), balance) {
 489 |     |             return false;
 490 |     |         } catch {
 491 |     |             return true;
 492 |     |         }
 493 |     |     }
 494 |     | 
 495 |     |     // Select an actor by index, clamped to valid range
 496 |     |     function _selectActor(
 497 |     |         uint8 index
 498 |     |     ) internal returns (StakerActor actor) {
 499 |     |         uint256 actorIndex = clampBetween(uint256(index), 0, actors.length - 1);
 500 |     |         return actors[actorIndex];
 501 |     |     }
 502 |     | 
 503 |     |     // Overflow check for two uint256 values
 504 |     |     function _overflowCheck(uint256 a, uint256 b) internal pure {
 505 |     |         uint256 c;
 506 |     |         unchecked {
 507 |     |             c = a + b;
 508 |     |         }
 509 |     |         require(c >= a, "OVERFLOW!");
 510 |     |     }
 511 |     | 
 512 |     |     // Get staking token balance of the staker contract
 513 |     |     function _stakingTokenBalanceOfStaker() internal view returns (uint256 assets) {
 514 |     |         assets = stakingToken.balanceOf(address(staker));
 515 |     |     }
 516 |     | 
 517 |     |     //Overflow check
 518 | *   |     function generate_overflow_stake(
 519 |     |         uint8 actorIndex
 520 |     |     ) public {
 521 | *   |         uint256 max = type(uint256).max;
 522 | *r  |         stakingToken.mint(address(actors[actorIndex]), max);
 523 |     |         stake(actorIndex, max);
 524 |     |     }
 525 |     | 
 526 |     |     function echidna_ERC20_sumBalancesNoOverflow() public view returns (bool) {
 527 |     |         uint256 sum = 0;
 528 |     |         for (uint256 i = 0; i < actors.length; i++) {
 529 |     |             // overflow check utility before adding
 530 |     |             _overflowCheck(sum, stakingToken.balanceOf(address(actors[i])));
 531 |     |             sum += stakingToken.balanceOf(address(actors[i]));
 532 |     |         }
 533 |     |         // Check overflow for adding staker contract's balance
 534 |     |         _overflowCheck(sum, stakingToken.balanceOf(address(staker)));
 535 |     |         sum += stakingToken.balanceOf(address(staker));
 536 |     | 
 537 |     |         // The sum should never exceed total supply
 538 |     |         return sum <= stakingToken.totalSupply();
 539 |     |     }
 540 |     | }
 541 |     | 

