/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/access/AccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IAccessControl} from "./IAccessControl.sol";
   7 |     | import {Context} from "../utils/Context.sol";
   8 |     | import {ERC165} from "../utils/introspection/ERC165.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Contract module that allows children to implement role-based access
  12 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  13 |     |  * members except through off-chain means by accessing the contract event logs. Some
  14 |     |  * applications may benefit from on-chain enumerability, for those cases see
  15 |     |  * {AccessControlEnumerable}.
  16 |     |  *
  17 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  18 |     |  * in the external API and be unique. The best way to achieve this is by
  19 |     |  * using `public constant` hash digests:
  20 |     |  *
  21 |     |  * ```solidity
  22 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  23 |     |  * ```
  24 |     |  *
  25 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  26 |     |  * function call, use {hasRole}:
  27 |     |  *
  28 |     |  * ```solidity
  29 |     |  * function foo() public {
  30 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  31 |     |  *     ...
  32 |     |  * }
  33 |     |  * ```
  34 |     |  *
  35 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  36 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  37 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  38 |     |  *
  39 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  40 |     |  * that only accounts with this role will be able to grant or revoke other
  41 |     |  * roles. More complex role relationships can be created by using
  42 |     |  * {_setRoleAdmin}.
  43 |     |  *
  44 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  45 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  46 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  47 |     |  * to enforce additional security measures for this role.
  48 |     |  */
  49 |     | abstract contract AccessControl is Context, IAccessControl, ERC165 {
  50 |     |     struct RoleData {
  51 |     |         mapping(address account => bool) hasRole;
  52 |     |         bytes32 adminRole;
  53 |     |     }
  54 |     | 
  55 |     |     mapping(bytes32 role => RoleData) private _roles;
  56 |     | 
  57 | *   |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  61 |     |      * with an {AccessControlUnauthorizedAccount} error including the required role.
  62 |     |      */
  63 |     |     modifier onlyRole(bytes32 role) {
  64 | *   |         _checkRole(role);
  65 |     |         _;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev See {IERC165-supportsInterface}.
  70 |     |      */
  71 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  72 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Returns `true` if `account` has been granted `role`.
  77 |     |      */
  78 | *   |     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
  79 | *   |         return _roles[role].hasRole[account];
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
  84 |     |      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
  85 |     |      */
  86 | *   |     function _checkRole(bytes32 role) internal view virtual {
  87 | *   |         _checkRole(role, _msgSender());
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
  92 |     |      * is missing `role`.
  93 |     |      */
  94 | *   |     function _checkRole(bytes32 role, address account) internal view virtual {
  95 | *   |         if (!hasRole(role, account)) {
  96 |     |             revert AccessControlUnauthorizedAccount(account, role);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 102 |     |      * {revokeRole}.
 103 |     |      *
 104 |     |      * To change a role's admin, use {_setRoleAdmin}.
 105 |     |      */
 106 | *   |     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
 107 | *   |         return _roles[role].adminRole;
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Grants `role` to `account`.
 112 |     |      *
 113 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 114 |     |      * event.
 115 |     |      *
 116 |     |      * Requirements:
 117 |     |      *
 118 |     |      * - the caller must have ``role``'s admin role.
 119 |     |      *
 120 |     |      * May emit a {RoleGranted} event.
 121 |     |      */
 122 | *   |     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 123 | *   |         _grantRole(role, account);
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Revokes `role` from `account`.
 128 |     |      *
 129 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 130 |     |      *
 131 |     |      * Requirements:
 132 |     |      *
 133 |     |      * - the caller must have ``role``'s admin role.
 134 |     |      *
 135 |     |      * May emit a {RoleRevoked} event.
 136 |     |      */
 137 |     |     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 138 |     |         _revokeRole(role, account);
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @dev Revokes `role` from the calling account.
 143 |     |      *
 144 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 145 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 146 |     |      * if they are compromised (such as when a trusted device is misplaced).
 147 |     |      *
 148 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 149 |     |      * event.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - the caller must be `callerConfirmation`.
 154 |     |      *
 155 |     |      * May emit a {RoleRevoked} event.
 156 |     |      */
 157 |     |     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
 158 |     |         if (callerConfirmation != _msgSender()) {
 159 |     |             revert AccessControlBadConfirmation();
 160 |     |         }
 161 |     | 
 162 |     |         _revokeRole(role, callerConfirmation);
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 167 |     |      *
 168 |     |      * Emits a {RoleAdminChanged} event.
 169 |     |      */
 170 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 171 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 172 |     |         _roles[role].adminRole = adminRole;
 173 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
 178 |     |      *
 179 |     |      * Internal function without access restriction.
 180 |     |      *
 181 |     |      * May emit a {RoleGranted} event.
 182 |     |      */
 183 | *   |     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
 184 | *   |         if (!hasRole(role, account)) {
 185 | *   |             _roles[role].hasRole[account] = true;
 186 | *   |             emit RoleGranted(role, account, _msgSender());
 187 | *   |             return true;
 188 |     |         } else {
 189 | *   |             return false;
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
 195 |     |      *
 196 |     |      * Internal function without access restriction.
 197 |     |      *
 198 |     |      * May emit a {RoleRevoked} event.
 199 |     |      */
 200 |     |     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
 201 |     |         if (hasRole(role, account)) {
 202 |     |             _roles[role].hasRole[account] = false;
 203 |     |             emit RoleRevoked(role, account, _msgSender());
 204 |     |             return true;
 205 |     |         } else {
 206 |     |             return false;
 207 |     |         }
 208 |     |     }
 209 |     | }
 210 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev External interface of AccessControl declared to support ERC165 detection.
   8 |     |  */
   9 |     | interface IAccessControl {
  10 |     |     /**
  11 |     |      * @dev The `account` is missing a role.
  12 |     |      */
  13 |     |     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev The caller of a function is not the expected one.
  17 |     |      *
  18 |     |      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
  19 |     |      */
  20 |     |     error AccessControlBadConfirmation();
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
  24 |     |      *
  25 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
  26 |     |      * {RoleAdminChanged} not being emitted signaling this.
  27 |     |      */
  28 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` is granted `role`.
  32 |     |      *
  33 |     |      * `sender` is the account that originated the contract call, an admin role
  34 |     |      * bearer except when using {AccessControl-_setupRole}.
  35 |     |      */
  36 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when `account` is revoked `role`.
  40 |     |      *
  41 |     |      * `sender` is the account that originated the contract call:
  42 |     |      *   - if using `revokeRole`, it is the admin role bearer
  43 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
  44 |     |      */
  45 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns `true` if `account` has been granted `role`.
  49 |     |      */
  50 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
  54 |     |      * {revokeRole}.
  55 |     |      *
  56 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
  57 |     |      */
  58 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Grants `role` to `account`.
  62 |     |      *
  63 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
  64 |     |      * event.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - the caller must have ``role``'s admin role.
  69 |     |      */
  70 |     |     function grantRole(bytes32 role, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Revokes `role` from `account`.
  74 |     |      *
  75 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
  76 |     |      *
  77 |     |      * Requirements:
  78 |     |      *
  79 |     |      * - the caller must have ``role``'s admin role.
  80 |     |      */
  81 |     |     function revokeRole(bytes32 role, address account) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Revokes `role` from the calling account.
  85 |     |      *
  86 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
  87 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
  88 |     |      * if they are compromised (such as when a trusted device is misplaced).
  89 |     |      *
  90 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
  91 |     |      * event.
  92 |     |      *
  93 |     |      * Requirements:
  94 |     |      *
  95 |     |      * - the caller must be `callerConfirmation`.
  96 |     |      */
  97 |     |     function renounceRole(bytes32 role, address callerConfirmation) external;
  98 |     | }
  99 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Standard ERC20 Errors
   7 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
   8 |     |  */
   9 |     | interface IERC20Errors {
  10 |     |     /**
  11 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
  12 |     |      * @param sender Address whose tokens are being transferred.
  13 |     |      * @param balance Current balance for the interacting account.
  14 |     |      * @param needed Minimum amount required to perform a transfer.
  15 |     |      */
  16 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  20 |     |      * @param sender Address whose tokens are being transferred.
  21 |     |      */
  22 |     |     error ERC20InvalidSender(address sender);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  26 |     |      * @param receiver Address to which tokens are being transferred.
  27 |     |      */
  28 |     |     error ERC20InvalidReceiver(address receiver);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
  32 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  33 |     |      * @param allowance Amount of tokens a `spender` is allowed to operate with.
  34 |     |      * @param needed Minimum amount required to perform a transfer.
  35 |     |      */
  36 |     |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  40 |     |      * @param approver Address initiating an approval operation.
  41 |     |      */
  42 |     |     error ERC20InvalidApprover(address approver);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
  46 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  47 |     |      */
  48 |     |     error ERC20InvalidSpender(address spender);
  49 |     | }
  50 |     | 
  51 |     | /**
  52 |     |  * @dev Standard ERC721 Errors
  53 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
  54 |     |  */
  55 |     | interface IERC721Errors {
  56 |     |     /**
  57 |     |      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.
  58 |     |      * Used in balance queries.
  59 |     |      * @param owner Address of the current owner of a token.
  60 |     |      */
  61 |     |     error ERC721InvalidOwner(address owner);
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Indicates a `tokenId` whose `owner` is the zero address.
  65 |     |      * @param tokenId Identifier number of a token.
  66 |     |      */
  67 |     |     error ERC721NonexistentToken(uint256 tokenId);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
  71 |     |      * @param sender Address whose tokens are being transferred.
  72 |     |      * @param tokenId Identifier number of a token.
  73 |     |      * @param owner Address of the current owner of a token.
  74 |     |      */
  75 |     |     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  79 |     |      * @param sender Address whose tokens are being transferred.
  80 |     |      */
  81 |     |     error ERC721InvalidSender(address sender);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  85 |     |      * @param receiver Address to which tokens are being transferred.
  86 |     |      */
  87 |     |     error ERC721InvalidReceiver(address receiver);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
  91 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
  92 |     |      * @param tokenId Identifier number of a token.
  93 |     |      */
  94 |     |     error ERC721InsufficientApproval(address operator, uint256 tokenId);
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  98 |     |      * @param approver Address initiating an approval operation.
  99 |     |      */
 100 |     |     error ERC721InvalidApprover(address approver);
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 104 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 105 |     |      */
 106 |     |     error ERC721InvalidOperator(address operator);
 107 |     | }
 108 |     | 
 109 |     | /**
 110 |     |  * @dev Standard ERC1155 Errors
 111 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
 112 |     |  */
 113 |     | interface IERC1155Errors {
 114 |     |     /**
 115 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
 116 |     |      * @param sender Address whose tokens are being transferred.
 117 |     |      * @param balance Current balance for the interacting account.
 118 |     |      * @param needed Minimum amount required to perform a transfer.
 119 |     |      * @param tokenId Identifier number of a token.
 120 |     |      */
 121 |     |     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
 125 |     |      * @param sender Address whose tokens are being transferred.
 126 |     |      */
 127 |     |     error ERC1155InvalidSender(address sender);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
 131 |     |      * @param receiver Address to which tokens are being transferred.
 132 |     |      */
 133 |     |     error ERC1155InvalidReceiver(address receiver);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
 137 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 138 |     |      * @param owner Address of the current owner of a token.
 139 |     |      */
 140 |     |     error ERC1155MissingApprovalForAll(address operator, address owner);
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
 144 |     |      * @param approver Address initiating an approval operation.
 145 |     |      */
 146 |     |     error ERC1155InvalidApprover(address approver);
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 150 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 151 |     |      */
 152 |     |     error ERC1155InvalidOperator(address operator);
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
 156 |     |      * Used in batch transfers.
 157 |     |      * @param idsLength Length of the array of token identifiers
 158 |     |      * @param valuesLength Length of the array of token amounts
 159 |     |      */
 160 |     |     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
 161 |     | }
 162 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "./IERC20.sol";
   7 |     | import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";
   8 |     | import {Context} from "../../utils/Context.sol";
   9 |     | import {IERC20Errors} from "../../interfaces/draft-IERC6093.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  */
  34 |     | abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
  35 |     |     mapping(address account => uint256) private _balances;
  36 |     | 
  37 |     |     mapping(address account => mapping(address spender => uint256)) private _allowances;
  38 |     | 
  39 |     |     uint256 private _totalSupply;
  40 |     | 
  41 |     |     string private _name;
  42 |     |     string private _symbol;
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Sets the values for {name} and {symbol}.
  46 |     |      *
  47 |     |      * All two of these values are immutable: they can only be set once during
  48 |     |      * construction.
  49 |     |      */
  50 | *   |     constructor(string memory name_, string memory symbol_) {
  51 | *   |         _name = name_;
  52 | *   |         _symbol = symbol_;
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Returns the name of the token.
  57 |     |      */
  58 |     |     function name() public view virtual returns (string memory) {
  59 |     |         return _name;
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  64 |     |      * name.
  65 |     |      */
  66 |     |     function symbol() public view virtual returns (string memory) {
  67 |     |         return _symbol;
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Returns the number of decimals used to get its user representation.
  72 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  73 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  74 |     |      *
  75 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  76 |     |      * Ether and Wei. This is the default value returned by this function, unless
  77 |     |      * it's overridden.
  78 |     |      *
  79 |     |      * NOTE: This information is only used for _display_ purposes: it in
  80 |     |      * no way affects any of the arithmetic of the contract, including
  81 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  82 |     |      */
  83 |     |     function decimals() public view virtual returns (uint8) {
  84 |     |         return 18;
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev See {IERC20-totalSupply}.
  89 |     |      */
  90 |     |     function totalSupply() public view virtual returns (uint256) {
  91 |     |         return _totalSupply;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev See {IERC20-balanceOf}.
  96 |     |      */
  97 | *   |     function balanceOf(address account) public view virtual returns (uint256) {
  98 | *   |         return _balances[account];
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev See {IERC20-transfer}.
 103 |     |      *
 104 |     |      * Requirements:
 105 |     |      *
 106 |     |      * - `to` cannot be the zero address.
 107 |     |      * - the caller must have a balance of at least `value`.
 108 |     |      */
 109 |     |     function transfer(address to, uint256 value) public virtual returns (bool) {
 110 |     |         address owner = _msgSender();
 111 |     |         _transfer(owner, to, value);
 112 |     |         return true;
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev See {IERC20-allowance}.
 117 |     |      */
 118 | *   |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 119 | *   |         return _allowances[owner][spender];
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev See {IERC20-approve}.
 124 |     |      *
 125 |     |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 126 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 127 |     |      *
 128 |     |      * Requirements:
 129 |     |      *
 130 |     |      * - `spender` cannot be the zero address.
 131 |     |      */
 132 | *   |     function approve(address spender, uint256 value) public virtual returns (bool) {
 133 | *   |         address owner = _msgSender();
 134 | *   |         _approve(owner, spender, value);
 135 | *   |         return true;
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev See {IERC20-transferFrom}.
 140 |     |      *
 141 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 142 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 143 |     |      *
 144 |     |      * NOTE: Does not update the allowance if the current allowance
 145 |     |      * is the maximum `uint256`.
 146 |     |      *
 147 |     |      * Requirements:
 148 |     |      *
 149 |     |      * - `from` and `to` cannot be the zero address.
 150 |     |      * - `from` must have a balance of at least `value`.
 151 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 152 |     |      * `value`.
 153 |     |      */
 154 | *   |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 155 | *   |         address spender = _msgSender();
 156 | *   |         _spendAllowance(from, spender, value);
 157 | *   |         _transfer(from, to, value);
 158 | *   |         return true;
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 163 |     |      *
 164 |     |      * This internal function is equivalent to {transfer}, and can be used to
 165 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 166 |     |      *
 167 |     |      * Emits a {Transfer} event.
 168 |     |      *
 169 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 170 |     |      */
 171 | *   |     function _transfer(address from, address to, uint256 value) internal {
 172 | *   |         if (from == address(0)) {
 173 |     |             revert ERC20InvalidSender(address(0));
 174 |     |         }
 175 | *   |         if (to == address(0)) {
 176 |     |             revert ERC20InvalidReceiver(address(0));
 177 |     |         }
 178 | *   |         _update(from, to, value);
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 183 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 184 |     |      * this function.
 185 |     |      *
 186 |     |      * Emits a {Transfer} event.
 187 |     |      */
 188 | *   |     function _update(address from, address to, uint256 value) internal virtual {
 189 | *   |         if (from == address(0)) {
 190 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 191 | *   |             _totalSupply += value;
 192 | *   |         } else {
 193 | *   |             uint256 fromBalance = _balances[from];
 194 | *   |             if (fromBalance < value) {
 195 |     |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 196 |     |             }
 197 |     |             unchecked {
 198 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 199 | *   |                 _balances[from] = fromBalance - value;
 200 |     |             }
 201 |     |         }
 202 |     | 
 203 | *   |         if (to == address(0)) {
 204 |     |             unchecked {
 205 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 206 |     |                 _totalSupply -= value;
 207 |     |             }
 208 |     |         } else {
 209 |     |             unchecked {
 210 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 211 | *   |                 _balances[to] += value;
 212 |     |             }
 213 |     |         }
 214 |     | 
 215 | *   |         emit Transfer(from, to, value);
 216 |     |     }
 217 |     | 
 218 |     |     /**
 219 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 220 |     |      * Relies on the `_update` mechanism
 221 |     |      *
 222 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 223 |     |      *
 224 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 225 |     |      */
 226 | *   |     function _mint(address account, uint256 value) internal {
 227 | *   |         if (account == address(0)) {
 228 |     |             revert ERC20InvalidReceiver(address(0));
 229 |     |         }
 230 | *   |         _update(address(0), account, value);
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 235 |     |      * Relies on the `_update` mechanism.
 236 |     |      *
 237 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 238 |     |      *
 239 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 240 |     |      */
 241 |     |     function _burn(address account, uint256 value) internal {
 242 |     |         if (account == address(0)) {
 243 |     |             revert ERC20InvalidSender(address(0));
 244 |     |         }
 245 |     |         _update(account, address(0), value);
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.
 250 |     |      *
 251 |     |      * This internal function is equivalent to `approve`, and can be used to
 252 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 253 |     |      *
 254 |     |      * Emits an {Approval} event.
 255 |     |      *
 256 |     |      * Requirements:
 257 |     |      *
 258 |     |      * - `owner` cannot be the zero address.
 259 |     |      * - `spender` cannot be the zero address.
 260 |     |      *
 261 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 262 |     |      */
 263 | *   |     function _approve(address owner, address spender, uint256 value) internal {
 264 | *   |         _approve(owner, spender, value, true);
 265 |     |     }
 266 |     | 
 267 |     |     /**
 268 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 269 |     |      *
 270 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 271 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 272 |     |      * `Approval` event during `transferFrom` operations.
 273 |     |      *
 274 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 275 |     |      * true using the following override:
 276 |     |      * ```
 277 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 278 |     |      *     super._approve(owner, spender, value, true);
 279 |     |      * }
 280 |     |      * ```
 281 |     |      *
 282 |     |      * Requirements are the same as {_approve}.
 283 |     |      */
 284 | *   |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 285 | *   |         if (owner == address(0)) {
 286 |     |             revert ERC20InvalidApprover(address(0));
 287 |     |         }
 288 | *   |         if (spender == address(0)) {
 289 |     |             revert ERC20InvalidSpender(address(0));
 290 |     |         }
 291 | *   |         _allowances[owner][spender] = value;
 292 | *   |         if (emitEvent) {
 293 | *   |             emit Approval(owner, spender, value);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `value`.
 299 |     |      *
 300 |     |      * Does not update the allowance value in case of infinite allowance.
 301 |     |      * Revert if not enough allowance is available.
 302 |     |      *
 303 |     |      * Does not emit an {Approval} event.
 304 |     |      */
 305 | *   |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 306 | *   |         uint256 currentAllowance = allowance(owner, spender);
 307 | *   |         if (currentAllowance != type(uint256).max) {
 308 | *   |             if (currentAllowance < value) {
 309 |     |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 310 |     |             }
 311 |     |             unchecked {
 312 | *   |                 _approve(owner, spender, currentAllowance - value, false);
 313 |     |             }
 314 |     |         }
 315 |     |     }
 316 |     | }
 317 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "../IERC20.sol";
   7 |     | import {IERC20Permit} from "../extensions/IERC20Permit.sol";
   8 |     | import {Address} from "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev An operation with an ERC20 token failed.
  24 |     |      */
  25 |     |     error SafeERC20FailedOperation(address token);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Indicates a failed `decreaseAllowance` request.
  29 |     |      */
  30 |     |     error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  34 |     |      * non-reverting calls are assumed to be successful.
  35 |     |      */
  36 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  37 |     |         _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  42 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  43 |     |      */
  44 | *   |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  45 | *   |         _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  50 |     |      * non-reverting calls are assumed to be successful.
  51 |     |      */
  52 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  53 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  54 |     |         forceApprove(token, spender, oldAllowance + value);
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no
  59 |     |      * value, non-reverting calls are assumed to be successful.
  60 |     |      */
  61 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
  62 |     |         unchecked {
  63 |     |             uint256 currentAllowance = token.allowance(address(this), spender);
  64 |     |             if (currentAllowance < requestedDecrease) {
  65 |     |                 revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
  66 |     |             }
  67 |     |             forceApprove(token, spender, currentAllowance - requestedDecrease);
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  73 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  74 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  75 |     |      */
  76 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  77 |     |         bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
  78 |     | 
  79 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  80 |     |             _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
  81 |     |             _callOptionalReturn(token, approvalCall);
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
  87 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
  88 |     |      * @param token The token targeted by the call.
  89 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
  90 |     |      */
  91 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
  92 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
  93 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
  94 |     |         // the target address contains contract code and also asserts for success in the low-level call.
  95 |     | 
  96 | *   |         bytes memory returndata = address(token).functionCall(data);
  97 | *   |         if (returndata.length != 0 && !abi.decode(returndata, (bool))) {
  98 |     |             revert SafeERC20FailedOperation(address(token));
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 104 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 105 |     |      * @param token The token targeted by the call.
 106 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 107 |     |      *
 108 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 109 |     |      */
 110 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 111 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 112 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 113 |     |         // and not revert is the subcall reverts.
 114 |     | 
 115 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 116 |     |         return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;
 117 |     |     }
 118 |     | }
 119 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev The ETH balance of the account is not enough to perform the operation.
  12 |     |      */
  13 |     |     error AddressInsufficientBalance(address account);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev There's no code at `target` (it is not a contract).
  17 |     |      */
  18 |     |     error AddressEmptyCode(address target);
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev A call to an address target failed. The target may have reverted.
  22 |     |      */
  23 |     |     error FailedInnerCall();
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  27 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  28 |     |      *
  29 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  30 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  31 |     |      * imposed by `transfer`, making them unable to receive funds via
  32 |     |      * `transfer`. {sendValue} removes this limitation.
  33 |     |      *
  34 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  35 |     |      *
  36 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  37 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  38 |     |      * {ReentrancyGuard} or the
  39 |     |      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  40 |     |      */
  41 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  42 |     |         if (address(this).balance < amount) {
  43 |     |             revert AddressInsufficientBalance(address(this));
  44 |     |         }
  45 |     | 
  46 |     |         (bool success, ) = recipient.call{value: amount}("");
  47 |     |         if (!success) {
  48 |     |             revert FailedInnerCall();
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  54 |     |      * plain `call` is an unsafe replacement for a function call: use this
  55 |     |      * function instead.
  56 |     |      *
  57 |     |      * If `target` reverts with a revert reason or custom error, it is bubbled
  58 |     |      * up by this function (like regular Solidity function calls). However, if
  59 |     |      * the call reverted with no returned reason, this function reverts with a
  60 |     |      * {FailedInnerCall} error.
  61 |     |      *
  62 |     |      * Returns the raw returned data. To convert to the expected return value,
  63 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  64 |     |      *
  65 |     |      * Requirements:
  66 |     |      *
  67 |     |      * - `target` must be a contract.
  68 |     |      * - calling `target` with `data` must not revert.
  69 |     |      */
  70 | *   |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  71 | *   |         return functionCallWithValue(target, data, 0);
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  76 |     |      * but also transferring `value` wei to `target`.
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - the calling contract must have an ETH balance of at least `value`.
  81 |     |      * - the called Solidity function must be `payable`.
  82 |     |      */
  83 | *   |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  84 | *   |         if (address(this).balance < value) {
  85 |     |             revert AddressInsufficientBalance(address(this));
  86 |     |         }
  87 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  88 | *   |         return verifyCallResultFromTarget(target, success, returndata);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  93 |     |      * but performing a static call.
  94 |     |      */
  95 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
  96 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
  97 |     |         return verifyCallResultFromTarget(target, success, returndata);
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 102 |     |      * but performing a delegate call.
 103 |     |      */
 104 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 105 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 106 |     |         return verifyCallResultFromTarget(target, success, returndata);
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
 111 |     |      * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
 112 |     |      * unsuccessful call.
 113 |     |      */
 114 | *   |     function verifyCallResultFromTarget(
 115 |     |         address target,
 116 |     |         bool success,
 117 |     |         bytes memory returndata
 118 | *   |     ) internal view returns (bytes memory) {
 119 | *   |         if (!success) {
 120 |     |             _revert(returndata);
 121 |     |         } else {
 122 |     |             // only check if target is a contract if the call was successful and the return data is empty
 123 |     |             // otherwise we already know that it was a contract
 124 | *   |             if (returndata.length == 0 && target.code.length == 0) {
 125 |     |                 revert AddressEmptyCode(target);
 126 |     |             }
 127 | *   |             return returndata;
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
 133 |     |      * revert reason or with a default {FailedInnerCall} error.
 134 |     |      */
 135 |     |     function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
 136 |     |         if (!success) {
 137 |     |             _revert(returndata);
 138 |     |         } else {
 139 |     |             return returndata;
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
 145 |     |      */
 146 |     |     function _revert(bytes memory returndata) private pure {
 147 |     |         // Look for revert reason and bubble it up if present
 148 |     |         if (returndata.length > 0) {
 149 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 150 |     |             /// @solidity memory-safe-assembly
 151 |     |             assembly {
 152 |     |                 let returndata_size := mload(returndata)
 153 |     |                 revert(add(32, returndata), returndata_size)
 154 |     |             }
 155 |     |         } else {
 156 |     |             revert FailedInnerCall();
 157 |     |         }
 158 |     |     }
 159 |     | }
 160 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Pausable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Context} from "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which allows children to implement an emergency stop
  10 |     |  * mechanism that can be triggered by an authorized account.
  11 |     |  *
  12 |     |  * This module is used through inheritance. It will make available the
  13 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  14 |     |  * the functions of your contract. Note that they will not be pausable by
  15 |     |  * simply including this module, only once the modifiers are put in place.
  16 |     |  */
  17 |     | abstract contract Pausable is Context {
  18 |     |     bool private _paused;
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev Emitted when the pause is triggered by `account`.
  22 |     |      */
  23 |     |     event Paused(address account);
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Emitted when the pause is lifted by `account`.
  27 |     |      */
  28 |     |     event Unpaused(address account);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev The operation failed because the contract is paused.
  32 |     |      */
  33 |     |     error EnforcedPause();
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev The operation failed because the contract is not paused.
  37 |     |      */
  38 |     |     error ExpectedPause();
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Initializes the contract in unpaused state.
  42 |     |      */
  43 |     |     constructor() {
  44 | *   |         _paused = false;
  45 |     |     }
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  49 |     |      *
  50 |     |      * Requirements:
  51 |     |      *
  52 |     |      * - The contract must not be paused.
  53 |     |      */
  54 |     |     modifier whenNotPaused() {
  55 | *   |         _requireNotPaused();
  56 |     |         _;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  61 |     |      *
  62 |     |      * Requirements:
  63 |     |      *
  64 |     |      * - The contract must be paused.
  65 |     |      */
  66 |     |     modifier whenPaused() {
  67 |     |         _requirePaused();
  68 |     |         _;
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  73 |     |      */
  74 | *   |     function paused() public view virtual returns (bool) {
  75 | *   |         return _paused;
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Throws if the contract is paused.
  80 |     |      */
  81 | *   |     function _requireNotPaused() internal view virtual {
  82 | *   |         if (paused()) {
  83 |     |             revert EnforcedPause();
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Throws if the contract is not paused.
  89 |     |      */
  90 |     |     function _requirePaused() internal view virtual {
  91 |     |         if (!paused()) {
  92 |     |             revert ExpectedPause();
  93 |     |         }
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Triggers stopped state.
  98 |     |      *
  99 |     |      * Requirements:
 100 |     |      *
 101 |     |      * - The contract must not be paused.
 102 |     |      */
 103 |     |     function _pause() internal virtual whenNotPaused {
 104 |     |         _paused = true;
 105 |     |         emit Paused(_msgSender());
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Returns to normal state.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - The contract must be paused.
 114 |     |      */
 115 |     |     function _unpause() internal virtual whenPaused {
 116 |     |         _paused = false;
 117 |     |         emit Unpaused(_msgSender());
 118 |     |     }
 119 |     | }
 120 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 | *   |     uint256 private constant NOT_ENTERED = 1;
 35 | *   |     uint256 private constant ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     /**
 40 |     |      * @dev Unauthorized reentrant call.
 41 |     |      */
 42 |     |     error ReentrancyGuardReentrantCall();
 43 |     | 
 44 |     |     constructor() {
 45 | *   |         _status = NOT_ENTERED;
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 50 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 51 |     |      * function is not supported. It is possible to prevent this from happening
 52 |     |      * by making the `nonReentrant` function external, and making it call a
 53 |     |      * `private` function that does the actual work.
 54 |     |      */
 55 |     |     modifier nonReentrant() {
 56 | *   |         _nonReentrantBefore();
 57 |     |         _;
 58 | *   |         _nonReentrantAfter();
 59 |     |     }
 60 |     | 
 61 | *   |     function _nonReentrantBefore() private {
 62 |     |         // On the first call to nonReentrant, _status will be NOT_ENTERED
 63 | *   |         if (_status == ENTERED) {
 64 |     |             revert ReentrancyGuardReentrantCall();
 65 |     |         }
 66 |     | 
 67 |     |         // Any calls to nonReentrant after this point will fail
 68 | *   |         _status = ENTERED;
 69 |     |     }
 70 |     | 
 71 | *   |     function _nonReentrantAfter() private {
 72 |     |         // By storing the original value once again, a refund is triggered (see
 73 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 74 | *   |         _status = NOT_ENTERED;
 75 |     |     }
 76 |     | 
 77 |     |     /**
 78 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 79 |     |      * `nonReentrant` function in the call stack.
 80 |     |      */
 81 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 82 |     |         return _status == ENTERED;
 83 |     |     }
 84 |     | }
 85 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  */
 20 |     | abstract contract ERC165 is IERC165 {
 21 |     |     /**
 22 |     |      * @dev See {IERC165-supportsInterface}.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
 25 |     |         return interfaceId == type(IERC165).interfaceId;
 26 |     |     }
 27 |     | }
 28 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/src/Staker.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   6 |     | import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
   7 |     | import "@openzeppelin/contracts/utils/Pausable.sol";
   8 |     | import "@openzeppelin/contracts/access/AccessControl.sol";
   9 |     | 
  10 | *   | contract Staker is AccessControl, ReentrancyGuard, Pausable {
  11 |     |     using SafeERC20 for IERC20;
  12 |     | 
  13 | *   |     bytes32 public constant REWARDS_ADMIN_ROLE = keccak256("REWARDS_ADMIN_ROLE");
  14 | *   |     bytes32 public constant PAUSE_GUARDIAN_ROLE = keccak256("PAUSE_GUARDIAN_ROLE");
  15 |     | 
  16 |     |     // Events
  17 |     |     event Staked(address indexed user, uint256 amount);
  18 |     |     event Withdrawn(address indexed user, uint256 amount);
  19 |     |     event RewardAdded(address indexed token, uint256 amount, uint256 duration);
  20 |     |     event RewardClaimed(address indexed user, address indexed token, uint256 amount);
  21 |     |     event RewardTokenRemoved(address indexed token);
  22 |     | 
  23 |     |     IERC20 public immutable stakingToken;
  24 |     |     IERC20[] public rewardTokens;
  25 |     |     mapping(address => bool) public isRewardToken;
  26 |     | 
  27 |     |     struct Reward {
  28 |     |         uint256 duration;
  29 |     |         uint256 rate;
  30 |     |         uint256 lastUpdateTime;
  31 |     |         uint256 rewardPerTokenStored;
  32 |     |     }
  33 |     | 
  34 |     |     mapping(address => Reward) public rewards;
  35 |     |     mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;
  36 |     |     mapping(address => mapping(address => uint256)) public rewardsEarned;
  37 |     | 
  38 |     |     uint256 private _totalStaked;
  39 |     |     mapping(address => uint256) private _stakedBalances;
  40 |     | 
  41 | *   |     constructor(address _stakingToken, address _admin, address _pauseGuardian) {
  42 | *   |         require(_stakingToken != address(0), "Invalid staking token");
  43 | *   |         require(_admin != address(0), "Invalid admin address");
  44 | *   |         require(_pauseGuardian != address(0), "Invalid pause guardian");
  45 |     | 
  46 | *   |         stakingToken = IERC20(_stakingToken);
  47 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, _admin);
  48 | *   |         _grantRole(REWARDS_ADMIN_ROLE, _admin);
  49 | *   |         _grantRole(PAUSE_GUARDIAN_ROLE, _pauseGuardian);
  50 |     |     }
  51 |     | 
  52 | *   |     function stake(
  53 |     |         uint256 amount
  54 |     |     ) external nonReentrant whenNotPaused {
  55 | *   |         require(amount > 0, "Cannot stake 0");
  56 | *   |         _updateRewards(msg.sender);
  57 |     | 
  58 | *   |         _totalStaked += amount;
  59 | *   |         _stakedBalances[msg.sender] += amount;
  60 |     | 
  61 | *   |         stakingToken.safeTransferFrom(msg.sender, address(this), amount);
  62 | *   |         emit Staked(msg.sender, amount);
  63 |     |     }
  64 |     | 
  65 |     |     function withdraw(
  66 |     |         uint256 amount
  67 |     |     ) external nonReentrant whenNotPaused {
  68 |     |         require(amount > 0, "Cannot withdraw 0");
  69 |     |         require(_stakedBalances[msg.sender] >= amount, "Insufficient balance");
  70 |     |         _updateRewards(msg.sender);
  71 |     | 
  72 |     |         _totalStaked -= amount;
  73 |     |         _stakedBalances[msg.sender] -= amount;
  74 |     | 
  75 |     |         stakingToken.safeTransfer(msg.sender, amount);
  76 |     |         emit Withdrawn(msg.sender, amount);
  77 |     |     }
  78 |     | 
  79 |     |     function claimRewards(
  80 |     |         address rewardToken
  81 |     |     ) external nonReentrant {
  82 |     |         require(isRewardToken[rewardToken], "Invalid reward token");
  83 |     |         _updateRewards(msg.sender);
  84 |     | 
  85 |     |         uint256 reward = rewardsEarned[msg.sender][rewardToken];
  86 |     |         require(reward > 0, "No rewards to claim");
  87 |     | 
  88 |     |         rewardsEarned[msg.sender][rewardToken] = 0;
  89 |     |         IERC20(rewardToken).safeTransfer(msg.sender, reward);
  90 |     |         emit RewardClaimed(msg.sender, rewardToken, reward);
  91 |     |     }
  92 |     | 
  93 |     |     // function addReward(
  94 |     |     //     address rewardToken,
  95 |     |     //     uint256 totalRewards,
  96 |     |     //     uint256 duration
  97 |     |     // ) external onlyRole(REWARDS_ADMIN_ROLE) {
  98 |     |     //     require(rewardToken != address(0), "Invalid reward token");
  99 |     |     //     require(totalRewards > 0 && duration > 0, "Invalid parameters");
 100 |     |     //     require(totalRewards % duration == 0, "TotalRewards must be divisible by duration");
 101 |     | 
 102 |     |     //     Reward storage reward = rewards[rewardToken];
 103 |     |     //     if (reward.duration > 0) {
 104 |     |     //         require(block.timestamp >= reward.lastUpdateTime + reward.duration, "Previous reward ongoing");
 105 |     |     //     }
 106 |     | 
 107 |     |     //     // Handle leftover tokens
 108 |     |     //     uint256 currentBalance = IERC20(rewardToken).balanceOf(address(this));
 109 |     |     //     require(totalRewards > currentBalance, "Insufficient new rewards");
 110 |     |     //     uint256 adjustedTotal = totalRewards - currentBalance;
 111 |     | 
 112 |     |     //     // Prevent duplicate entries
 113 |     |     //     if (!isRewardToken[rewardToken]) {
 114 |     |     //         bool isAlreadyInArray = false;
 115 |     |     //         for (uint256 i = 0; i < rewardTokens.length; i++) {
 116 |     |     //             if (address(rewardTokens[i]) == rewardToken) {
 117 |     |     //                 isAlreadyInArray = true;
 118 |     |     //                 break;
 119 |     |     //             }
 120 |     |     //         }
 121 |     |     //         if (!isAlreadyInArray) {
 122 |     |     //             rewardTokens.push(IERC20(rewardToken));
 123 |     |     //         }
 124 |     |     //         isRewardToken[rewardToken] = true;
 125 |     |     //     }
 126 |     | 
 127 |     |     //     uint256 rate = adjustedTotal / duration;
 128 |     |     //     rewards[rewardToken] = Reward(duration, rate, block.timestamp, 0);
 129 |     | 
 130 |     |     //     IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), totalRewards);
 131 |     |     //     emit RewardAdded(rewardToken, adjustedTotal, duration);
 132 |     |     // }
 133 |     | 
 134 |     |     // In Staker.sol
 135 | *   |     function addReward(address token, uint256 totalRewards, uint256 duration) external onlyRole(REWARDS_ADMIN_ROLE) {
 136 | *   |         require(duration > 0, "Invalid duration");
 137 |     | 
 138 |     |         // Calculate actual needed amount
 139 | *   |         uint256 currentBalance = IERC20(token).balanceOf(address(this));
 140 | *   |         require(totalRewards > currentBalance, "Insufficient new rewards");
 141 | *   |         uint256 adjustedTotal = totalRewards - currentBalance;
 142 |     | 
 143 |     |         // Validate divisibility
 144 | *   |         require(adjustedTotal % duration == 0, "Adjusted amount not divisible by duration");
 145 |     | 
 146 |     |         // Store reward data
 147 |     |         rewards[token] = Reward({
 148 |     |             duration: duration,
 149 |     |             rate: adjustedTotal / duration,
 150 |     |             lastUpdateTime: block.timestamp,
 151 |     |             rewardPerTokenStored: 0
 152 |     |         });
 153 |     | 
 154 |     |         // Transfer only the needed amount
 155 |     |         IERC20(token).safeTransferFrom(msg.sender, address(this), adjustedTotal);
 156 |     |         emit RewardAdded(token, adjustedTotal, duration);
 157 |     |     }
 158 |     | 
 159 |     |     function removeRewardToken(
 160 |     |         address rewardToken
 161 |     |     ) external onlyRole(REWARDS_ADMIN_ROLE) {
 162 |     |         require(isRewardToken[rewardToken], "Not a reward token");
 163 |     |         require(
 164 |     |             block.timestamp >= rewards[rewardToken].lastUpdateTime + rewards[rewardToken].duration, "Reward ongoing"
 165 |     |         );
 166 |     | 
 167 |     |         isRewardToken[rewardToken] = false;
 168 |     | 
 169 |     |         // Remove all instances from array
 170 |     |         uint256 i = 0;
 171 |     |         while (i < rewardTokens.length) {
 172 |     |             if (address(rewardTokens[i]) == rewardToken) {
 173 |     |                 rewardTokens[i] = rewardTokens[rewardTokens.length - 1];
 174 |     |                 rewardTokens.pop();
 175 |     |             } else {
 176 |     |                 i++;
 177 |     |             }
 178 |     |         }
 179 |     |         emit RewardTokenRemoved(rewardToken);
 180 |     |     }
 181 |     | 
 182 | *   |     function _updateRewards(
 183 |     |         address user
 184 |     |     ) internal {
 185 | *   |         for (uint256 i = 0; i < rewardTokens.length; i++) {
 186 |     |             address token = address(rewardTokens[i]);
 187 |     |             if (!isRewardToken[token]) continue;
 188 |     | 
 189 |     |             Reward storage reward = rewards[token];
 190 |     |             reward.rewardPerTokenStored = _rewardPerToken(token);
 191 |     |             reward.lastUpdateTime = lastTimeRewardApplicable(token);
 192 |     | 
 193 |     |             if (user != address(0)) {
 194 |     |                 rewardsEarned[user][token] = earned(user, token);
 195 |     |                 userRewardPerTokenPaid[user][token] = reward.rewardPerTokenStored;
 196 |     |             }
 197 |     |         }
 198 |     |     }
 199 |     | 
 200 |     |     function lastTimeRewardApplicable(
 201 |     |         address rewardToken
 202 |     |     ) public view returns (uint256) {
 203 |     |         Reward storage reward = rewards[rewardToken];
 204 |     |         return block.timestamp < reward.lastUpdateTime + reward.duration
 205 |     |             ? block.timestamp
 206 |     |             : reward.lastUpdateTime + reward.duration;
 207 |     |     }
 208 |     | 
 209 |     |     function _rewardPerToken(
 210 |     |         address rewardToken
 211 |     |     ) internal view returns (uint256) {
 212 |     |         Reward storage reward = rewards[rewardToken];
 213 |     |         if (_totalStaked == 0) return reward.rewardPerTokenStored;
 214 |     | 
 215 |     |         uint256 timeElapsed = lastTimeRewardApplicable(rewardToken) - reward.lastUpdateTime;
 216 |     |         return reward.rewardPerTokenStored + (timeElapsed * reward.rate * 1e18) / _totalStaked;
 217 |     |     }
 218 |     | 
 219 |     |     function earned(address user, address rewardToken) public view returns (uint256) {
 220 |     |         uint256 userRewardPerToken = _rewardPerToken(rewardToken) - userRewardPerTokenPaid[user][rewardToken];
 221 |     |         return (_stakedBalances[user] * userRewardPerToken) / 1e18 + rewardsEarned[user][rewardToken];
 222 |     |     }
 223 |     | 
 224 | *   |     function totalStaked() external view returns (uint256) {
 225 | *   |         return _totalStaked;
 226 |     |     }
 227 |     | 
 228 | *   |     function stakedBalanceOf(
 229 |     |         address user
 230 | *   |     ) external view returns (uint256) {
 231 | *   |         return _stakedBalances[user];
 232 |     |     }
 233 |     | 
 234 |     |     function claimAllRewards() external nonReentrant {
 235 |     |         _updateRewards(msg.sender);
 236 |     | 
 237 |     |         for (uint256 i = 0; i < rewardTokens.length; i++) {
 238 |     |             address token = address(rewardTokens[i]);
 239 |     |             uint256 reward = rewardsEarned[msg.sender][token];
 240 |     |             if (reward > 0 && isRewardToken[token]) {
 241 |     |                 rewardsEarned[msg.sender][token] = 0;
 242 |     |                 IERC20(token).safeTransfer(msg.sender, reward);
 243 |     |                 emit RewardClaimed(msg.sender, token, reward);
 244 |     |             }
 245 |     |         }
 246 |     |     }
 247 |     | }
 248 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/test/EchidnaTesting/TestStaker.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "../../src/Staker.sol";
   5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
   6 |     | 
   7 |     | import {MockERC20} from "../mocks/MockERC20.sol";
   8 |     | 
   9 | *   | contract TestStaker {
  10 |     |     using SafeERC20 for IERC20;
  11 |     | 
  12 |     |     Staker public staker;
  13 |     |     MockERC20 public stakingToken;
  14 |     |     MockERC20 public rewardToken;
  15 |     | 
  16 |     |     // Test state tracking for invariants
  17 |     |     uint256 public totalRewardsAdded;
  18 |     |     uint256 public totalRewardsClaimed;
  19 | *   |     mapping(address => uint256) public trackedUserBalances;
  20 |     | 
  21 | *   |     constructor() {
  22 |     |         // Deploy tokens
  23 | *   |         stakingToken = new MockERC20("Staking Token", "STK");
  24 | *   |         rewardToken = new MockERC20("Reward Token", "REW");
  25 |     | 
  26 |     |         // Deploy staker with this contract as admin and guardian
  27 | *   |         staker = new Staker(address(stakingToken), address(this), address(this));
  28 |     | 
  29 |     |         // Grant roles
  30 | *   |         staker.grantRole(staker.REWARDS_ADMIN_ROLE(), address(this));
  31 | *   |         staker.grantRole(staker.PAUSE_GUARDIAN_ROLE(), address(this));
  32 |     | 
  33 |     |         // Mint initial testing supply (use reasonable amounts)
  34 | *   |         stakingToken.mint(address(this), 1_000_000 ether);
  35 | *   |         rewardToken.mint(address(this), 1_000_000 ether);
  36 |     |     }
  37 |     | 
  38 |     |     // Echidna property: Total staked should match sum of individual balances
  39 |     |     function echidna_totalStakedMatchesBalances() public view returns (bool) {
  40 |     |         return staker.totalStaked() == trackedUserBalances[address(this)];
  41 |     |     }
  42 |     | 
  43 |     |     // Echidna property: Contract balance should cover total staked
  44 |     |     function echidna_balanceCoversTotalStaked() public view returns (bool) {
  45 |     |         return stakingToken.balanceOf(address(staker)) >= staker.totalStaked();
  46 |     |     }
  47 |     | 
  48 |     |     // Echidna property: Rewards claimed cannot exceed rewards added
  49 |     |     function echidna_rewardsClaimedUnderTotal() public view returns (bool) {
  50 |     |         return totalRewardsClaimed <= totalRewardsAdded;
  51 |     |     }
  52 |     | 
  53 |     |     // Helper function for input validation
  54 | *   |     function bound(uint256 value, uint256 min, uint256 max) internal pure returns (uint256) {
  55 | *   |         require(min <= max, "Invalid bounds");
  56 | *   |         return min + (value % (max - min + 1));
  57 |     |     }
  58 |     | 
  59 |     |     // Test function to stake tokens
  60 | *   |     function testStake(
  61 |     |         uint256 amount
  62 | *   |     ) public {
  63 |     |         // Bound amount to reasonable values
  64 | *   |         amount = bound(amount, 1, 1_000_000 ether);
  65 |     | 
  66 |     |         // Track state before
  67 | *   |         uint256 totalBefore = staker.totalStaked();
  68 | *   |         uint256 userBalanceBefore = staker.stakedBalanceOf(address(this));
  69 | *   |         uint256 contractBalanceBefore = stakingToken.balanceOf(address(staker));
  70 |     | 
  71 |     |         // Approve and stake
  72 | *   |         stakingToken.approve(address(staker), amount);
  73 |     | 
  74 | *   |         try staker.stake(amount) {
  75 |     |             // Update tracked balances
  76 | *   |             trackedUserBalances[address(this)] += amount;
  77 |     | 
  78 |     |             // Verify state changes
  79 | *   |             assert(staker.totalStaked() == totalBefore + amount);
  80 | *   |             assert(staker.stakedBalanceOf(address(this)) == userBalanceBefore + amount);
  81 | *   |             assert(stakingToken.balanceOf(address(staker)) == contractBalanceBefore + amount);
  82 |     |         } catch {
  83 |     |             // Stake might fail due to pause or invalid amount
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     // Test function to add rewards
  88 | *   |     function testAddReward(uint256 amount, uint256 duration) public {
  89 | *   |         amount = bound(amount, 1 ether, 100_000 ether);
  90 | *   |         duration = bound(duration, 1 days, 365 days);
  91 |     | 
  92 | *   |         rewardToken.approve(address(staker), amount);
  93 |     | 
  94 | *   |         try staker.addReward(address(rewardToken), amount, duration) {
  95 |     |             totalRewardsAdded += amount;
  96 |     |         } catch {
  97 |     |             // Adding reward might fail due to invalid parameters
  98 |     |         }
  99 |     |     }
 100 |     | }
 101 |     | 

/workspaces/codespaces-blank/Malo-Labs/contracts/test/mocks/MockERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 | *   | contract MockERC20 is ERC20 {
  7 | *   |     constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
  8 |     | 
  9 | *   |     function mint(address account, uint256 amount) public {
 10 | *   |         _mint(account, amount);
 11 |     |     }
 12 |     | }
 13 |     | 

