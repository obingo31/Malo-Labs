<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/access/AccessControl.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IAccessControl} from &quot;./IAccessControl.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Context} from &quot;../utils/Context.sol&quot;;</span>
   8 |     | <span class='neutral'>import {ERC165} from &quot;../utils/introspection/ERC165.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Contract module that allows children to implement role-based access</span>
  12 |     | <span class='neutral'> * control mechanisms. This is a lightweight version that doesn&#39;t allow enumerating role</span>
  13 |     | <span class='neutral'> * members except through off-chain means by accessing the contract event logs. Some</span>
  14 |     | <span class='neutral'> * applications may benefit from on-chain enumerability, for those cases see</span>
  15 |     | <span class='neutral'> * {AccessControlEnumerable}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * Roles are referred to by their `bytes32` identifier. These should be exposed</span>
  18 |     | <span class='neutral'> * in the external API and be unique. The best way to achieve this is by</span>
  19 |     | <span class='neutral'> * using `public constant` hash digests:</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * ```solidity</span>
  22 |     | <span class='neutral'> * bytes32 public constant MY_ROLE = keccak256(&quot;MY_ROLE&quot;);</span>
  23 |     | <span class='neutral'> * ```</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * Roles can be used to represent a set of permissions. To restrict access to a</span>
  26 |     | <span class='neutral'> * function call, use {hasRole}:</span>
  27 |     | <span class='neutral'> *</span>
  28 |     | <span class='neutral'> * ```solidity</span>
  29 |     | <span class='neutral'> * function foo() public {</span>
  30 |     | <span class='neutral'> *     require(hasRole(MY_ROLE, msg.sender));</span>
  31 |     | <span class='neutral'> *     ...</span>
  32 |     | <span class='neutral'> * }</span>
  33 |     | <span class='neutral'> * ```</span>
  34 |     | <span class='neutral'> *</span>
  35 |     | <span class='neutral'> * Roles can be granted and revoked dynamically via the {grantRole} and</span>
  36 |     | <span class='neutral'> * {revokeRole} functions. Each role has an associated admin role, and only</span>
  37 |     | <span class='neutral'> * accounts that have a role&#39;s admin role can call {grantRole} and {revokeRole}.</span>
  38 |     | <span class='neutral'> *</span>
  39 |     | <span class='neutral'> * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means</span>
  40 |     | <span class='neutral'> * that only accounts with this role will be able to grant or revoke other</span>
  41 |     | <span class='neutral'> * roles. More complex role relationships can be created by using</span>
  42 |     | <span class='neutral'> * {_setRoleAdmin}.</span>
  43 |     | <span class='neutral'> *</span>
  44 |     | <span class='neutral'> * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to</span>
  45 |     | <span class='neutral'> * grant and revoke this role. Extra precautions should be taken to secure</span>
  46 |     | <span class='neutral'> * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}</span>
  47 |     | <span class='neutral'> * to enforce additional security measures for this role.</span>
  48 |     | <span class='neutral'> */</span>
  49 |     | <span class='neutral'>abstract contract AccessControl is Context, IAccessControl, ERC165 {</span>
  50 |     | <span class='neutral'>    struct RoleData {</span>
  51 |     | <span class='neutral'>        mapping(address account =&gt; bool) hasRole;</span>
  52 |     | <span class='neutral'>        bytes32 adminRole;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    mapping(bytes32 role =&gt; RoleData) private _roles;</span>
  56 |     | <span class='neutral'></span>
  57 | *   | <span class='executed'>    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Modifier that checks that an account has a specific role. Reverts</span>
  61 |     | <span class='neutral'>     * with an {AccessControlUnauthorizedAccount} error including the required role.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    modifier onlyRole(bytes32 role) {</span>
  64 | *   | <span class='executed'>        _checkRole(role);</span>
  65 |     | <span class='neutral'>        _;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /**</span>
  69 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
  72 |     | <span class='unexecuted'>        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev Returns `true` if `account` has been granted `role`.</span>
  77 |     | <span class='neutral'>     */</span>
  78 | *   | <span class='executed'>    function hasRole(bytes32 role, address account) public view virtual returns (bool) {</span>
  79 | *   | <span class='executed'>        return _roles[role].hasRole[account];</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`</span>
  84 |     | <span class='neutral'>     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.</span>
  85 |     | <span class='neutral'>     */</span>
  86 | *   | <span class='executed'>    function _checkRole(bytes32 role) internal view virtual {</span>
  87 | *   | <span class='executed'>        _checkRole(role, _msgSender());</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`</span>
  92 |     | <span class='neutral'>     * is missing `role`.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function _checkRole(bytes32 role, address account) internal view virtual {</span>
  95 | *   | <span class='executed'>        if (!hasRole(role, account)) {</span>
  96 |     | <span class='unexecuted'>            revert AccessControlUnauthorizedAccount(account, role);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Returns the admin role that controls `role`. See {grantRole} and</span>
 102 |     | <span class='neutral'>     * {revokeRole}.</span>
 103 |     | <span class='neutral'>     *</span>
 104 |     | <span class='neutral'>     * To change a role&#39;s admin, use {_setRoleAdmin}.</span>
 105 |     | <span class='neutral'>     */</span>
 106 |     | <span class='unexecuted'>    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {</span>
 107 |     | <span class='unexecuted'>        return _roles[role].adminRole;</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
 114 |     | <span class='neutral'>     * event.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * Requirements:</span>
 117 |     | <span class='neutral'>     *</span>
 118 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 119 |     | <span class='neutral'>     *</span>
 120 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 121 |     | <span class='neutral'>     */</span>
 122 |     | <span class='unexecuted'>    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {</span>
 123 |     | <span class='unexecuted'>        _grantRole(role, account);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * If `account` had been granted `role`, emits a {RoleRevoked} event.</span>
 130 |     | <span class='neutral'>     *</span>
 131 |     | <span class='neutral'>     * Requirements:</span>
 132 |     | <span class='neutral'>     *</span>
 133 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 134 |     | <span class='neutral'>     *</span>
 135 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 136 |     | <span class='neutral'>     */</span>
 137 |     | <span class='unexecuted'>    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {</span>
 138 |     | <span class='unexecuted'>        _revokeRole(role, account);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    /**</span>
 142 |     | <span class='neutral'>     * @dev Revokes `role` from the calling account.</span>
 143 |     | <span class='neutral'>     *</span>
 144 |     | <span class='neutral'>     * Roles are often managed via {grantRole} and {revokeRole}: this function&#39;s</span>
 145 |     | <span class='neutral'>     * purpose is to provide a mechanism for accounts to lose their privileges</span>
 146 |     | <span class='neutral'>     * if they are compromised (such as when a trusted device is misplaced).</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * If the calling account had been revoked `role`, emits a {RoleRevoked}</span>
 149 |     | <span class='neutral'>     * event.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - the caller must be `callerConfirmation`.</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='unexecuted'>    function renounceRole(bytes32 role, address callerConfirmation) public virtual {</span>
 158 |     | <span class='unexecuted'>        if (callerConfirmation != _msgSender()) {</span>
 159 |     | <span class='unexecuted'>            revert AccessControlBadConfirmation();</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>        _revokeRole(role, callerConfirmation);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Sets `adminRole` as ``role``&#39;s admin role.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * Emits a {RoleAdminChanged} event.</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {</span>
 171 |     | <span class='neutral'>        bytes32 previousAdminRole = getRoleAdmin(role);</span>
 172 |     | <span class='neutral'>        _roles[role].adminRole = adminRole;</span>
 173 |     | <span class='neutral'>        emit RoleAdminChanged(role, previousAdminRole, adminRole);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /**</span>
 177 |     | <span class='neutral'>     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.</span>
 178 |     | <span class='neutral'>     *</span>
 179 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 180 |     | <span class='neutral'>     *</span>
 181 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 182 |     | <span class='neutral'>     */</span>
 183 | *   | <span class='executed'>    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {</span>
 184 | *   | <span class='executed'>        if (!hasRole(role, account)) {</span>
 185 | *   | <span class='executed'>            _roles[role].hasRole[account] = true;</span>
 186 | *   | <span class='executed'>            emit RoleGranted(role, account, _msgSender());</span>
 187 | *   | <span class='executed'>            return true;</span>
 188 |     | <span class='neutral'>        } else {</span>
 189 |     | <span class='unexecuted'>            return false;</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>    /**</span>
 194 |     | <span class='neutral'>     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.</span>
 195 |     | <span class='neutral'>     *</span>
 196 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 197 |     | <span class='neutral'>     *</span>
 198 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 199 |     | <span class='neutral'>     */</span>
 200 |     | <span class='unexecuted'>    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {</span>
 201 |     | <span class='unexecuted'>        if (hasRole(role, account)) {</span>
 202 |     | <span class='unexecuted'>            _roles[role].hasRole[account] = false;</span>
 203 |     | <span class='unexecuted'>            emit RoleRevoked(role, account, _msgSender());</span>
 204 |     | <span class='unexecuted'>            return true;</span>
 205 |     | <span class='neutral'>        } else {</span>
 206 |     | <span class='unexecuted'>            return false;</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'>}</span>
 210 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev External interface of AccessControl declared to support ERC165 detection.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>interface IAccessControl {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev The `account` is missing a role.</span>
  12 |     | <span class='neutral'>     */</span>
  13 |     | <span class='neutral'>    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /**</span>
  16 |     | <span class='neutral'>     * @dev The caller of a function is not the expected one.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * NOTE: Don&#39;t confuse with {AccessControlUnauthorizedAccount}.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    error AccessControlBadConfirmation();</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Emitted when `newAdminRole` is set as ``role``&#39;s admin role, replacing `previousAdminRole`</span>
  24 |     | <span class='neutral'>     *</span>
  25 |     | <span class='neutral'>     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite</span>
  26 |     | <span class='neutral'>     * {RoleAdminChanged} not being emitted signaling this.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Emitted when `account` is granted `role`.</span>
  32 |     | <span class='neutral'>     *</span>
  33 |     | <span class='neutral'>     * `sender` is the account that originated the contract call, an admin role</span>
  34 |     | <span class='neutral'>     * bearer except when using {AccessControl-_setupRole}.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Emitted when `account` is revoked `role`.</span>
  40 |     | <span class='neutral'>     *</span>
  41 |     | <span class='neutral'>     * `sender` is the account that originated the contract call:</span>
  42 |     | <span class='neutral'>     *   - if using `revokeRole`, it is the admin role bearer</span>
  43 |     | <span class='neutral'>     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Returns `true` if `account` has been granted `role`.</span>
  49 |     | <span class='neutral'>     */</span>
  50 |     | <span class='neutral'>    function hasRole(bytes32 role, address account) external view returns (bool);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @dev Returns the admin role that controls `role`. See {grantRole} and</span>
  54 |     | <span class='neutral'>     * {revokeRole}.</span>
  55 |     | <span class='neutral'>     *</span>
  56 |     | <span class='neutral'>     * To change a role&#39;s admin, use {AccessControl-_setRoleAdmin}.</span>
  57 |     | <span class='neutral'>     */</span>
  58 |     | <span class='neutral'>    function getRoleAdmin(bytes32 role) external view returns (bytes32);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
  62 |     | <span class='neutral'>     *</span>
  63 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
  64 |     | <span class='neutral'>     * event.</span>
  65 |     | <span class='neutral'>     *</span>
  66 |     | <span class='neutral'>     * Requirements:</span>
  67 |     | <span class='neutral'>     *</span>
  68 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function grantRole(bytes32 role, address account) external;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * If `account` had been granted `role`, emits a {RoleRevoked} event.</span>
  76 |     | <span class='neutral'>     *</span>
  77 |     | <span class='neutral'>     * Requirements:</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    function revokeRole(bytes32 role, address account) external;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Revokes `role` from the calling account.</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * Roles are often managed via {grantRole} and {revokeRole}: this function&#39;s</span>
  87 |     | <span class='neutral'>     * purpose is to provide a mechanism for accounts to lose their privileges</span>
  88 |     | <span class='neutral'>     * if they are compromised (such as when a trusted device is misplaced).</span>
  89 |     | <span class='neutral'>     *</span>
  90 |     | <span class='neutral'>     * If the calling account had been granted `role`, emits a {RoleRevoked}</span>
  91 |     | <span class='neutral'>     * event.</span>
  92 |     | <span class='neutral'>     *</span>
  93 |     | <span class='neutral'>     * Requirements:</span>
  94 |     | <span class='neutral'>     *</span>
  95 |     | <span class='neutral'>     * - the caller must be `callerConfirmation`.</span>
  96 |     | <span class='neutral'>     */</span>
  97 |     | <span class='neutral'>    function renounceRole(bytes32 role, address callerConfirmation) external;</span>
  98 |     | <span class='neutral'>}</span>
  99 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the value of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the value of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the</span>
 54 |     | <span class='neutral'>     * caller&#39;s tokens.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 59 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 60 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 61 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 62 |     | <span class='neutral'>     * desired value afterwards:</span>
 63 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 64 |     | <span class='neutral'>     *</span>
 65 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 66 |     | <span class='neutral'>     */</span>
 67 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    /**</span>
 70 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to` using the</span>
 71 |     | <span class='neutral'>     * allowance mechanism. `value` is then deducted from the caller&#39;s</span>
 72 |     | <span class='neutral'>     * allowance.</span>
 73 |     | <span class='neutral'>     *</span>
 74 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 75 |     | <span class='neutral'>     *</span>
 76 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 79 |     | <span class='neutral'>}</span>
 80 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ==== Security Considerations</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature</span>
 17 |     | <span class='neutral'> * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be</span>
 18 |     | <span class='neutral'> * considered as an intention to spend the allowance in any specific way. The second is that because permits have</span>
 19 |     | <span class='neutral'> * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should</span>
 20 |     | <span class='neutral'> * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be</span>
 21 |     | <span class='neutral'> * generally recommended is:</span>
 22 |     | <span class='neutral'> *</span>
 23 |     | <span class='neutral'> * ```solidity</span>
 24 |     | <span class='neutral'> * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {</span>
 25 |     | <span class='neutral'> *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}</span>
 26 |     | <span class='neutral'> *     doThing(..., value);</span>
 27 |     | <span class='neutral'> * }</span>
 28 |     | <span class='neutral'> *</span>
 29 |     | <span class='neutral'> * function doThing(..., uint256 value) public {</span>
 30 |     | <span class='neutral'> *     token.safeTransferFrom(msg.sender, address(this), value);</span>
 31 |     | <span class='neutral'> *     ...</span>
 32 |     | <span class='neutral'> * }</span>
 33 |     | <span class='neutral'> * ```</span>
 34 |     | <span class='neutral'> *</span>
 35 |     | <span class='neutral'> * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of</span>
 36 |     | <span class='neutral'> * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also</span>
 37 |     | <span class='neutral'> * {SafeERC20-safeTransferFrom}).</span>
 38 |     | <span class='neutral'> *</span>
 39 |     | <span class='neutral'> * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so</span>
 40 |     | <span class='neutral'> * contracts should have entry points that don&#39;t rely on permit.</span>
 41 |     | <span class='neutral'> */</span>
 42 |     | <span class='neutral'>interface IERC20Permit {</span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 45 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 48 |     | <span class='neutral'>     * ordering also apply here.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 51 |     | <span class='neutral'>     *</span>
 52 |     | <span class='neutral'>     * Requirements:</span>
 53 |     | <span class='neutral'>     *</span>
 54 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 55 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 56 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 57 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 58 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 59 |     | <span class='neutral'>     *</span>
 60 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 61 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 62 |     | <span class='neutral'>     * section].</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * CAUTION: See Security Considerations above.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function permit(</span>
 67 |     | <span class='neutral'>        address owner,</span>
 68 |     | <span class='neutral'>        address spender,</span>
 69 |     | <span class='neutral'>        uint256 value,</span>
 70 |     | <span class='neutral'>        uint256 deadline,</span>
 71 |     | <span class='neutral'>        uint8 v,</span>
 72 |     | <span class='neutral'>        bytes32 r,</span>
 73 |     | <span class='neutral'>        bytes32 s</span>
 74 |     | <span class='neutral'>    ) external;</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 78 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 79 |     | <span class='neutral'>     *</span>
 80 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 81 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 89 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IERC20} from &quot;../IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IERC20Permit} from &quot;../extensions/IERC20Permit.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Address} from &quot;../../../utils/Address.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title SafeERC20</span>
  12 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
  13 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
  14 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
  15 |     | <span class='neutral'> * successful.</span>
  16 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
  17 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library SafeERC20 {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev An operation with an ERC20 token failed.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    error SafeERC20FailedOperation(address token);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Indicates a failed `decreaseAllowance` request.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,</span>
  34 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  35 |     | <span class='neutral'>     */</span>
  36 | *   | <span class='executed'>    function safeTransfer(IERC20 token, address to, uint256 value) internal {</span>
  37 | *   | <span class='executed'>        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the</span>
  42 |     | <span class='neutral'>     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.</span>
  43 |     | <span class='neutral'>     */</span>
  44 | *   | <span class='executed'>    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {</span>
  45 | *   | <span class='executed'>        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Increase the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  50 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  53 |     | <span class='neutral'>        uint256 oldAllowance = token.allowance(address(this), spender);</span>
  54 |     | <span class='neutral'>        forceApprove(token, spender, oldAllowance + value);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev Decrease the calling contract&#39;s allowance toward `spender` by `requestedDecrease`. If `token` returns no</span>
  59 |     | <span class='neutral'>     * value, non-reverting calls are assumed to be successful.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {</span>
  62 |     | <span class='neutral'>        unchecked {</span>
  63 |     | <span class='neutral'>            uint256 currentAllowance = token.allowance(address(this), spender);</span>
  64 |     | <span class='neutral'>            if (currentAllowance &lt; requestedDecrease) {</span>
  65 |     | <span class='neutral'>                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='neutral'>            forceApprove(token, spender, currentAllowance - requestedDecrease);</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Set the calling contract&#39;s allowance toward `spender` to `value`. If `token` returns no value,</span>
  73 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval</span>
  74 |     | <span class='neutral'>     * to be set to zero before setting it to a non-zero value, such as USDT.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function forceApprove(IERC20 token, address spender, uint256 value) internal {</span>
  77 |     | <span class='neutral'>        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        if (!_callOptionalReturnBool(token, approvalCall)) {</span>
  80 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));</span>
  81 |     | <span class='neutral'>            _callOptionalReturn(token, approvalCall);</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
  87 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
  88 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
  89 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
  90 |     | <span class='neutral'>     */</span>
  91 | *   | <span class='executed'>    function _callOptionalReturn(IERC20 token, bytes memory data) private {</span>
  92 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
  93 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
  94 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>        bytes memory returndata = address(token).functionCall(data);</span>
  97 | *   | <span class='executed'>        if (returndata.length != 0 &amp;&amp; !abi.decode(returndata, (bool))) {</span>
  98 |     | <span class='unexecuted'>            revert SafeERC20FailedOperation(address(token));</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 104 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 105 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 106 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.</span>
 109 |     | <span class='neutral'>     */</span>
 110 |     | <span class='neutral'>    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {</span>
 111 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 112 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false</span>
 113 |     | <span class='neutral'>        // and not revert is the subcall reverts.</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        (bool success, bytes memory returndata) = address(token).call(data);</span>
 116 |     | <span class='neutral'>        return success &amp;&amp; (returndata.length == 0 || abi.decode(returndata, (bool))) &amp;&amp; address(token).code.length &gt; 0;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'>}</span>
 119 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev The ETH balance of the account is not enough to perform the operation.</span>
  12 |     | <span class='neutral'>     */</span>
  13 |     | <span class='neutral'>    error AddressInsufficientBalance(address account);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /**</span>
  16 |     | <span class='neutral'>     * @dev There&#39;s no code at `target` (it is not a contract).</span>
  17 |     | <span class='neutral'>     */</span>
  18 |     | <span class='neutral'>    error AddressEmptyCode(address target);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @dev A call to an address target failed. The target may have reverted.</span>
  22 |     | <span class='neutral'>     */</span>
  23 |     | <span class='neutral'>    error FailedInnerCall();</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /**</span>
  26 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  27 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  28 |     | <span class='neutral'>     *</span>
  29 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  30 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  31 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  32 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  33 |     | <span class='neutral'>     *</span>
  34 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  35 |     | <span class='neutral'>     *</span>
  36 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  37 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  38 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  39 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  42 |     | <span class='neutral'>        if (address(this).balance &lt; amount) {</span>
  43 |     | <span class='neutral'>            revert AddressInsufficientBalance(address(this));</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  47 |     | <span class='neutral'>        if (!success) {</span>
  48 |     | <span class='neutral'>            revert FailedInnerCall();</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  54 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  55 |     | <span class='neutral'>     * function instead.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * If `target` reverts with a revert reason or custom error, it is bubbled</span>
  58 |     | <span class='neutral'>     * up by this function (like regular Solidity function calls). However, if</span>
  59 |     | <span class='neutral'>     * the call reverted with no returned reason, this function reverts with a</span>
  60 |     | <span class='neutral'>     * {FailedInnerCall} error.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  63 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  64 |     | <span class='neutral'>     *</span>
  65 |     | <span class='neutral'>     * Requirements:</span>
  66 |     | <span class='neutral'>     *</span>
  67 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  68 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  69 |     | <span class='neutral'>     */</span>
  70 | *   | <span class='executed'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  71 | *   | <span class='executed'>        return functionCallWithValue(target, data, 0);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
  76 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * Requirements:</span>
  79 |     | <span class='neutral'>     *</span>
  80 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
  81 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
  82 |     | <span class='neutral'>     */</span>
  83 | *   | <span class='executed'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
  84 | *   | <span class='executed'>        if (address(this).balance &lt; value) {</span>
  85 |     | <span class='unexecuted'>            revert AddressInsufficientBalance(address(this));</span>
  86 |     | <span class='neutral'>        }</span>
  87 | *   | <span class='executed'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
  88 | *   | <span class='executed'>        return verifyCallResultFromTarget(target, success, returndata);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
  93 |     | <span class='neutral'>     * but performing a static call.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
  96 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
  97 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 102 |     | <span class='neutral'>     * but performing a delegate call.</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 105 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 106 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target</span>
 111 |     | <span class='neutral'>     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an</span>
 112 |     | <span class='neutral'>     * unsuccessful call.</span>
 113 |     | <span class='neutral'>     */</span>
 114 | *   | <span class='executed'>    function verifyCallResultFromTarget(</span>
 115 |     | <span class='neutral'>        address target,</span>
 116 |     | <span class='neutral'>        bool success,</span>
 117 |     | <span class='neutral'>        bytes memory returndata</span>
 118 | *   | <span class='executed'>    ) internal view returns (bytes memory) {</span>
 119 | *   | <span class='executed'>        if (!success) {</span>
 120 | *   | <span class='executed'>            _revert(returndata);</span>
 121 |     | <span class='neutral'>        } else {</span>
 122 |     | <span class='neutral'>            // only check if target is a contract if the call was successful and the return data is empty</span>
 123 |     | <span class='neutral'>            // otherwise we already know that it was a contract</span>
 124 | *   | <span class='executed'>            if (returndata.length == 0 &amp;&amp; target.code.length == 0) {</span>
 125 |     | <span class='unexecuted'>                revert AddressEmptyCode(target);</span>
 126 |     | <span class='neutral'>            }</span>
 127 | *   | <span class='executed'>            return returndata;</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and reverts if it wasn&#39;t, either by bubbling the</span>
 133 |     | <span class='neutral'>     * revert reason or with a default {FailedInnerCall} error.</span>
 134 |     | <span class='neutral'>     */</span>
 135 |     | <span class='neutral'>    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {</span>
 136 |     | <span class='neutral'>        if (!success) {</span>
 137 |     | <span class='neutral'>            _revert(returndata);</span>
 138 |     | <span class='neutral'>        } else {</span>
 139 |     | <span class='neutral'>            return returndata;</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.</span>
 145 |     | <span class='neutral'>     */</span>
 146 | *   | <span class='executed'>    function _revert(bytes memory returndata) private pure {</span>
 147 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 148 | *   | <span class='executed'>        if (returndata.length &gt; 0) {</span>
 149 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 150 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 151 |     | <span class='neutral'>            assembly {</span>
 152 | *   | <span class='executed'>                let returndata_size := mload(returndata)</span>
 153 | *   | <span class='executed'>                revert(add(32, returndata), returndata_size)</span>
 154 |     | <span class='neutral'>            }</span>
 155 |     | <span class='neutral'>        } else {</span>
 156 |     | <span class='unexecuted'>            revert FailedInnerCall();</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'>}</span>
 160 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 | *   | <span class='executed'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 26 |     | <span class='neutral'>        return 0;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Pausable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {Context} from &quot;../utils/Context.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Contract module which allows children to implement an emergency stop</span>
  10 |     | <span class='neutral'> * mechanism that can be triggered by an authorized account.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * This module is used through inheritance. It will make available the</span>
  13 |     | <span class='neutral'> * modifiers `whenNotPaused` and `whenPaused`, which can be applied to</span>
  14 |     | <span class='neutral'> * the functions of your contract. Note that they will not be pausable by</span>
  15 |     | <span class='neutral'> * simply including this module, only once the modifiers are put in place.</span>
  16 |     | <span class='neutral'> */</span>
  17 |     | <span class='neutral'>abstract contract Pausable is Context {</span>
  18 |     | <span class='neutral'>    bool private _paused;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    /**</span>
  21 |     | <span class='neutral'>     * @dev Emitted when the pause is triggered by `account`.</span>
  22 |     | <span class='neutral'>     */</span>
  23 |     | <span class='neutral'>    event Paused(address account);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /**</span>
  26 |     | <span class='neutral'>     * @dev Emitted when the pause is lifted by `account`.</span>
  27 |     | <span class='neutral'>     */</span>
  28 |     | <span class='neutral'>    event Unpaused(address account);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev The operation failed because the contract is paused.</span>
  32 |     | <span class='neutral'>     */</span>
  33 |     | <span class='neutral'>    error EnforcedPause();</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev The operation failed because the contract is not paused.</span>
  37 |     | <span class='neutral'>     */</span>
  38 |     | <span class='neutral'>    error ExpectedPause();</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Initializes the contract in unpaused state.</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='neutral'>    constructor() {</span>
  44 | *   | <span class='executed'>        _paused = false;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Modifier to make a function callable only when the contract is not paused.</span>
  49 |     | <span class='neutral'>     *</span>
  50 |     | <span class='neutral'>     * Requirements:</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * - The contract must not be paused.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    modifier whenNotPaused() {</span>
  55 | *   | <span class='executed'>        _requireNotPaused();</span>
  56 |     | <span class='neutral'>        _;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Modifier to make a function callable only when the contract is paused.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * Requirements:</span>
  63 |     | <span class='neutral'>     *</span>
  64 |     | <span class='neutral'>     * - The contract must be paused.</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='neutral'>    modifier whenPaused() {</span>
  67 |     | <span class='neutral'>        _requirePaused();</span>
  68 |     | <span class='neutral'>        _;</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Returns true if the contract is paused, and false otherwise.</span>
  73 |     | <span class='neutral'>     */</span>
  74 | *   | <span class='executed'>    function paused() public view virtual returns (bool) {</span>
  75 | *   | <span class='executed'>        return _paused;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @dev Throws if the contract is paused.</span>
  80 |     | <span class='neutral'>     */</span>
  81 | *   | <span class='executed'>    function _requireNotPaused() internal view virtual {</span>
  82 | *   | <span class='executed'>        if (paused()) {</span>
  83 |     | <span class='unexecuted'>            revert EnforcedPause();</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @dev Throws if the contract is not paused.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    function _requirePaused() internal view virtual {</span>
  91 |     | <span class='neutral'>        if (!paused()) {</span>
  92 |     | <span class='neutral'>            revert ExpectedPause();</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev Triggers stopped state.</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * Requirements:</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * - The contract must not be paused.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function _pause() internal virtual whenNotPaused {</span>
 104 |     | <span class='neutral'>        _paused = true;</span>
 105 |     | <span class='neutral'>        emit Paused(_msgSender());</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @dev Returns to normal state.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Requirements:</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * - The contract must be paused.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function _unpause() internal virtual whenPaused {</span>
 116 |     | <span class='neutral'>        _paused = false;</span>
 117 |     | <span class='neutral'>        emit Unpaused(_msgSender());</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'>}</span>
 120 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 10 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 11 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 14 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 15 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 16 |     | <span class='neutral'> * points to them.</span>
 17 |     | <span class='neutral'> *</span>
 18 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 19 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 20 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ReentrancyGuard {</span>
 23 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 24 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 25 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 26 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 27 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 30 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 31 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 32 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 33 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 34 | *   | <span class='executed'>    uint256 private constant NOT_ENTERED = 1;</span>
 35 | *   | <span class='executed'>    uint256 private constant ENTERED = 2;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    uint256 private _status;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @dev Unauthorized reentrant call.</span>
 41 |     | <span class='neutral'>     */</span>
 42 |     | <span class='neutral'>    error ReentrancyGuardReentrantCall();</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    constructor() {</span>
 45 | *   | <span class='executed'>        _status = NOT_ENTERED;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /**</span>
 49 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 50 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 51 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 52 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 53 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 54 |     | <span class='neutral'>     */</span>
 55 |     | <span class='neutral'>    modifier nonReentrant() {</span>
 56 | *   | <span class='executed'>        _nonReentrantBefore();</span>
 57 |     | <span class='neutral'>        _;</span>
 58 | *   | <span class='executed'>        _nonReentrantAfter();</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'></span>
 61 | *   | <span class='executed'>    function _nonReentrantBefore() private {</span>
 62 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be NOT_ENTERED</span>
 63 | *   | <span class='executed'>        if (_status == ENTERED) {</span>
 64 |     | <span class='unexecuted'>            revert ReentrancyGuardReentrantCall();</span>
 65 |     | <span class='neutral'>        }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 68 | *   | <span class='executed'>        _status = ENTERED;</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 | *   | <span class='executed'>    function _nonReentrantAfter() private {</span>
 72 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 73 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 74 | *   | <span class='executed'>        _status = NOT_ENTERED;</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    /**</span>
 78 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 79 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 80 |     | <span class='neutral'>     */</span>
 81 |     | <span class='neutral'>    function _reentrancyGuardEntered() internal view returns (bool) {</span>
 82 |     | <span class='neutral'>        return _status == ENTERED;</span>
 83 |     | <span class='neutral'>    }</span>
 84 |     | <span class='neutral'>}</span>
 85 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/Strings.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {Math} from &quot;./math/Math.sol&quot;;</span>
  7 |     | <span class='neutral'>import {SignedMath} from &quot;./math/SignedMath.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev String operations.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>library Strings {</span>
 13 |     | <span class='neutral'>    bytes16 private constant HEX_DIGITS = &quot;0123456789abcdef&quot;;</span>
 14 | *   | <span class='executed'>    uint8 private constant ADDRESS_LENGTH = 20;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev The `value` string doesn&#39;t fit in the specified `length`.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    error StringsInsufficientHexLength(uint256 value, uint256 length);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /**</span>
 22 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span>
 23 |     | <span class='neutral'>     */</span>
 24 | *   | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory) {</span>
 25 |     | <span class='neutral'>        unchecked {</span>
 26 | *   | <span class='executed'>            uint256 length = Math.log10(value) + 1;</span>
 27 | *   | <span class='executed'>            string memory buffer = new string(length);</span>
 28 | *   | <span class='executed'>            uint256 ptr;</span>
 29 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 30 |     | <span class='neutral'>            assembly {</span>
 31 | *   | <span class='executed'>                ptr := add(buffer, add(32, length))</span>
 32 |     | <span class='neutral'>            }</span>
 33 | *   | <span class='executed'>            while (true) {</span>
 34 | *   | <span class='executed'>                ptr--;</span>
 35 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 36 |     | <span class='neutral'>                assembly {</span>
 37 | *   | <span class='executed'>                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))</span>
 38 |     | <span class='neutral'>                }</span>
 39 | *   | <span class='executed'>                value /= 10;</span>
 40 | *   | <span class='executed'>                if (value == 0) break;</span>
 41 |     | <span class='neutral'>            }</span>
 42 | *   | <span class='executed'>            return buffer;</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /**</span>
 47 |     | <span class='neutral'>     * @dev Converts a `int256` to its ASCII `string` decimal representation.</span>
 48 |     | <span class='neutral'>     */</span>
 49 |     | <span class='neutral'>    function toStringSigned(int256 value) internal pure returns (string memory) {</span>
 50 |     | <span class='neutral'>        return string.concat(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, toString(SignedMath.abs(value)));</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /**</span>
 54 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span>
 55 |     | <span class='neutral'>     */</span>
 56 |     | <span class='neutral'>    function toHexString(uint256 value) internal pure returns (string memory) {</span>
 57 |     | <span class='neutral'>        unchecked {</span>
 58 |     | <span class='neutral'>            return toHexString(value, Math.log256(value) + 1);</span>
 59 |     | <span class='neutral'>        }</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    /**</span>
 63 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span>
 64 |     | <span class='neutral'>     */</span>
 65 | *   | <span class='executed'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {</span>
 66 | *   | <span class='executed'>        uint256 localValue = value;</span>
 67 | *   | <span class='executed'>        bytes memory buffer = new bytes(2 * length + 2);</span>
 68 | *   | <span class='executed'>        buffer[0] = &quot;0&quot;;</span>
 69 | *   | <span class='executed'>        buffer[1] = &quot;x&quot;;</span>
 70 | *   | <span class='executed'>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {</span>
 71 | *   | <span class='executed'>            buffer[i] = HEX_DIGITS[localValue &amp; 0xf];</span>
 72 | *   | <span class='executed'>            localValue &gt;&gt;= 4;</span>
 73 |     | <span class='neutral'>        }</span>
 74 | *   | <span class='executed'>        if (localValue != 0) {</span>
 75 |     | <span class='unexecuted'>            revert StringsInsufficientHexLength(value, length);</span>
 76 |     | <span class='neutral'>        }</span>
 77 | *   | <span class='executed'>        return string(buffer);</span>
 78 |     | <span class='neutral'>    }</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>    /**</span>
 81 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal</span>
 82 |     | <span class='neutral'>     * representation.</span>
 83 |     | <span class='neutral'>     */</span>
 84 | *   | <span class='executed'>    function toHexString(address addr) internal pure returns (string memory) {</span>
 85 | *   | <span class='executed'>        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);</span>
 86 |     | <span class='neutral'>    }</span>
 87 |     | <span class='neutral'></span>
 88 |     | <span class='neutral'>    /**</span>
 89 |     | <span class='neutral'>     * @dev Returns true if the two strings are equal.</span>
 90 |     | <span class='neutral'>     */</span>
 91 |     | <span class='neutral'>    function equal(string memory a, string memory b) internal pure returns (bool) {</span>
 92 |     | <span class='neutral'>        return bytes(a).length == bytes(b).length &amp;&amp; keccak256(bytes(a)) == keccak256(bytes(b));</span>
 93 |     | <span class='neutral'>    }</span>
 94 |     | <span class='neutral'>}</span>
 95 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {IERC165} from &quot;./IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 12 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ```solidity</span>
 15 |     | <span class='neutral'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 16 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 17 |     | <span class='neutral'> * }</span>
 18 |     | <span class='neutral'> * ```</span>
 19 |     | <span class='neutral'> */</span>
 20 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 21 |     | <span class='neutral'>    /**</span>
 22 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {</span>
 25 |     | <span class='unexecuted'>        return interfaceId == type(IERC165).interfaceId;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/math/Math.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Standard math utilities missing in the Solidity language.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Math {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Muldiv operation overflow.</span>
  12 |     | <span class='neutral'>     */</span>
  13 |     | <span class='neutral'>    error MathOverflowedMulDiv();</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    enum Rounding {</span>
  16 |     | <span class='neutral'>        Floor, // Toward negative infinity</span>
  17 |     | <span class='neutral'>        Ceil, // Toward positive infinity</span>
  18 |     | <span class='neutral'>        Trunc, // Toward zero</span>
  19 |     | <span class='neutral'>        Expand // Away from zero</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Returns the addition of two unsigned integers, with an overflow flag.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  26 |     | <span class='neutral'>        unchecked {</span>
  27 |     | <span class='neutral'>            uint256 c = a + b;</span>
  28 |     | <span class='neutral'>            if (c &lt; a) return (false, 0);</span>
  29 |     | <span class='neutral'>            return (true, c);</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /**</span>
  34 |     | <span class='neutral'>     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  37 |     | <span class='neutral'>        unchecked {</span>
  38 |     | <span class='neutral'>            if (b &gt; a) return (false, 0);</span>
  39 |     | <span class='neutral'>            return (true, a - b);</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  47 |     | <span class='neutral'>        unchecked {</span>
  48 |     | <span class='neutral'>            // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the</span>
  49 |     | <span class='neutral'>            // benefit is lost if &#39;b&#39; is also tested.</span>
  50 |     | <span class='neutral'>            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522</span>
  51 |     | <span class='neutral'>            if (a == 0) return (true, 0);</span>
  52 |     | <span class='neutral'>            uint256 c = a * b;</span>
  53 |     | <span class='neutral'>            if (c / a != b) return (false, 0);</span>
  54 |     | <span class='neutral'>            return (true, c);</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @dev Returns the division of two unsigned integers, with a division by zero flag.</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  62 |     | <span class='neutral'>        unchecked {</span>
  63 |     | <span class='neutral'>            if (b == 0) return (false, 0);</span>
  64 |     | <span class='neutral'>            return (true, a / b);</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /**</span>
  69 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='neutral'>    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  72 |     | <span class='neutral'>        unchecked {</span>
  73 |     | <span class='neutral'>            if (b == 0) return (false, 0);</span>
  74 |     | <span class='neutral'>            return (true, a % b);</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @dev Returns the largest of two numbers.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  82 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /**</span>
  86 |     | <span class='neutral'>     * @dev Returns the smallest of two numbers.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='neutral'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  89 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /**</span>
  93 |     | <span class='neutral'>     * @dev Returns the average of two numbers. The result is rounded towards</span>
  94 |     | <span class='neutral'>     * zero.</span>
  95 |     | <span class='neutral'>     */</span>
  96 |     | <span class='neutral'>    function average(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  97 |     | <span class='neutral'>        // (a + b) / 2 can overflow.</span>
  98 |     | <span class='neutral'>        return (a &amp; b) + (a ^ b) / 2;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev Returns the ceiling of the division of two numbers.</span>
 103 |     | <span class='neutral'>     *</span>
 104 |     | <span class='neutral'>     * This differs from standard division with `/` in that it rounds towards infinity instead</span>
 105 |     | <span class='neutral'>     * of rounding towards zero.</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='neutral'>    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 108 |     | <span class='neutral'>        if (b == 0) {</span>
 109 |     | <span class='neutral'>            // Guarantee the same behavior as in a regular Solidity division.</span>
 110 |     | <span class='neutral'>            return a / b;</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // (a + b - 1) / b can overflow on addition, so we distribute.</span>
 114 |     | <span class='neutral'>        return a == 0 ? 0 : (a - 1) / b + 1;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /**</span>
 118 |     | <span class='neutral'>     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or</span>
 119 |     | <span class='neutral'>     * denominator == 0.</span>
 120 |     | <span class='neutral'>     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by</span>
 121 |     | <span class='neutral'>     * Uniswap Labs also under MIT license.</span>
 122 |     | <span class='neutral'>     */</span>
 123 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {</span>
 124 |     | <span class='neutral'>        unchecked {</span>
 125 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use</span>
 126 |     | <span class='neutral'>            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256</span>
 127 |     | <span class='neutral'>            // variables such that product = prod1 * 2^256 + prod0.</span>
 128 |     | <span class='neutral'>            uint256 prod0 = x * y; // Least significant 256 bits of the product</span>
 129 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product</span>
 130 |     | <span class='neutral'>            assembly {</span>
 131 |     | <span class='neutral'>                let mm := mulmod(x, y, not(0))</span>
 132 |     | <span class='neutral'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
 133 |     | <span class='neutral'>            }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
 136 |     | <span class='neutral'>            if (prod1 == 0) {</span>
 137 |     | <span class='neutral'>                // Solidity will revert if denominator == 0, unlike the div opcode on its own.</span>
 138 |     | <span class='neutral'>                // The surrounding unchecked block does not change this fact.</span>
 139 |     | <span class='neutral'>                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.</span>
 140 |     | <span class='neutral'>                return prod0 / denominator;</span>
 141 |     | <span class='neutral'>            }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>            // Make sure the result is less than 2^256. Also prevents denominator == 0.</span>
 144 |     | <span class='neutral'>            if (denominator &lt;= prod1) {</span>
 145 |     | <span class='neutral'>                revert MathOverflowedMulDiv();</span>
 146 |     | <span class='neutral'>            }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
 149 |     | <span class='neutral'>            // 512 by 256 division.</span>
 150 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0].</span>
 153 |     | <span class='neutral'>            uint256 remainder;</span>
 154 |     | <span class='neutral'>            assembly {</span>
 155 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
 156 |     | <span class='neutral'>                remainder := mulmod(x, y, denominator)</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>                // Subtract 256 bit number from 512 bit number.</span>
 159 |     | <span class='neutral'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
 160 |     | <span class='neutral'>                prod0 := sub(prod0, remainder)</span>
 161 |     | <span class='neutral'>            }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.</span>
 164 |     | <span class='neutral'>            // Always &gt;= 1. See https://cs.stackexchange.com/q/138556/92363.</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>            uint256 twos = denominator &amp; (0 - denominator);</span>
 167 |     | <span class='neutral'>            assembly {</span>
 168 |     | <span class='neutral'>                // Divide denominator by twos.</span>
 169 |     | <span class='neutral'>                denominator := div(denominator, twos)</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>                // Divide [prod1 prod0] by twos.</span>
 172 |     | <span class='neutral'>                prod0 := div(prod0, twos)</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.</span>
 175 |     | <span class='neutral'>                twos := add(div(sub(0, twos), twos), 1)</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0.</span>
 179 |     | <span class='neutral'>            prod0 |= prod1 * twos;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such</span>
 182 |     | <span class='neutral'>            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for</span>
 183 |     | <span class='neutral'>            // four bits. That is, denominator * inv = 1 mod 2^4.</span>
 184 |     | <span class='neutral'>            uint256 inverse = (3 * denominator) ^ 2;</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel&#39;s lifting lemma, this also</span>
 187 |     | <span class='neutral'>            // works in modular arithmetic, doubling the correct bits in each step.</span>
 188 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^8</span>
 189 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^16</span>
 190 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^32</span>
 191 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^64</span>
 192 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^128</span>
 193 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^256</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.</span>
 196 |     | <span class='neutral'>            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is</span>
 197 |     | <span class='neutral'>            // less than 2^256, this is the final result. We don&#39;t need to compute the high bits of the result and prod1</span>
 198 |     | <span class='neutral'>            // is no longer required.</span>
 199 |     | <span class='neutral'>            result = prod0 * inverse;</span>
 200 |     | <span class='neutral'>            return result;</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /**</span>
 205 |     | <span class='neutral'>     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.</span>
 206 |     | <span class='neutral'>     */</span>
 207 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {</span>
 208 |     | <span class='neutral'>        uint256 result = mulDiv(x, y, denominator);</span>
 209 |     | <span class='neutral'>        if (unsignedRoundsUp(rounding) &amp;&amp; mulmod(x, y, denominator) &gt; 0) {</span>
 210 |     | <span class='neutral'>            result += 1;</span>
 211 |     | <span class='neutral'>        }</span>
 212 |     | <span class='neutral'>        return result;</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    /**</span>
 216 |     | <span class='neutral'>     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded</span>
 217 |     | <span class='neutral'>     * towards zero.</span>
 218 |     | <span class='neutral'>     *</span>
 219 |     | <span class='neutral'>     * Inspired by Henry S. Warren, Jr.&#39;s &quot;Hacker&#39;s Delight&quot; (Chapter 11).</span>
 220 |     | <span class='neutral'>     */</span>
 221 |     | <span class='neutral'>    function sqrt(uint256 a) internal pure returns (uint256) {</span>
 222 |     | <span class='neutral'>        if (a == 0) {</span>
 223 |     | <span class='neutral'>            return 0;</span>
 224 |     | <span class='neutral'>        }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.</span>
 227 |     | <span class='neutral'>        //</span>
 228 |     | <span class='neutral'>        // We know that the &quot;msb&quot; (most significant bit) of our target number `a` is a power of 2 such that we have</span>
 229 |     | <span class='neutral'>        // `msb(a) &lt;= a &lt; 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.</span>
 230 |     | <span class='neutral'>        //</span>
 231 |     | <span class='neutral'>        // This can be rewritten `2**log2(a) &lt;= a &lt; 2**(log2(a) + 1)`</span>
 232 |     | <span class='neutral'>        //  `sqrt(2**k) &lt;= sqrt(a) &lt; sqrt(2**(k+1))`</span>
 233 |     | <span class='neutral'>        //  `2**(k/2) &lt;= sqrt(a) &lt; 2**((k+1)/2) &lt;= 2**(k/2 + 1)`</span>
 234 |     | <span class='neutral'>        //</span>
 235 |     | <span class='neutral'>        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.</span>
 236 |     | <span class='neutral'>        uint256 result = 1 &lt;&lt; (log2(a) &gt;&gt; 1);</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,</span>
 239 |     | <span class='neutral'>        // since it is the square root of a uint256. Newton&#39;s method converges quadratically (precision doubles at</span>
 240 |     | <span class='neutral'>        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision</span>
 241 |     | <span class='neutral'>        // into the expected uint128 result.</span>
 242 |     | <span class='neutral'>        unchecked {</span>
 243 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 244 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 245 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 246 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 247 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 248 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 249 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 250 |     | <span class='neutral'>            return min(result, a / result);</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    /**</span>
 255 |     | <span class='neutral'>     * @notice Calculates sqrt(a), following the selected rounding direction.</span>
 256 |     | <span class='neutral'>     */</span>
 257 |     | <span class='neutral'>    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {</span>
 258 |     | <span class='neutral'>        unchecked {</span>
 259 |     | <span class='neutral'>            uint256 result = sqrt(a);</span>
 260 |     | <span class='neutral'>            return result + (unsignedRoundsUp(rounding) &amp;&amp; result * result &lt; a ? 1 : 0);</span>
 261 |     | <span class='neutral'>        }</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    /**</span>
 265 |     | <span class='neutral'>     * @dev Return the log in base 2 of a positive value rounded towards zero.</span>
 266 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 267 |     | <span class='neutral'>     */</span>
 268 |     | <span class='neutral'>    function log2(uint256 value) internal pure returns (uint256) {</span>
 269 |     | <span class='neutral'>        uint256 result = 0;</span>
 270 |     | <span class='neutral'>        unchecked {</span>
 271 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 272 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 273 |     | <span class='neutral'>                result += 128;</span>
 274 |     | <span class='neutral'>            }</span>
 275 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 276 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 277 |     | <span class='neutral'>                result += 64;</span>
 278 |     | <span class='neutral'>            }</span>
 279 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 280 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 281 |     | <span class='neutral'>                result += 32;</span>
 282 |     | <span class='neutral'>            }</span>
 283 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 284 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 285 |     | <span class='neutral'>                result += 16;</span>
 286 |     | <span class='neutral'>            }</span>
 287 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 288 |     | <span class='neutral'>                value &gt;&gt;= 8;</span>
 289 |     | <span class='neutral'>                result += 8;</span>
 290 |     | <span class='neutral'>            }</span>
 291 |     | <span class='neutral'>            if (value &gt;&gt; 4 &gt; 0) {</span>
 292 |     | <span class='neutral'>                value &gt;&gt;= 4;</span>
 293 |     | <span class='neutral'>                result += 4;</span>
 294 |     | <span class='neutral'>            }</span>
 295 |     | <span class='neutral'>            if (value &gt;&gt; 2 &gt; 0) {</span>
 296 |     | <span class='neutral'>                value &gt;&gt;= 2;</span>
 297 |     | <span class='neutral'>                result += 2;</span>
 298 |     | <span class='neutral'>            }</span>
 299 |     | <span class='neutral'>            if (value &gt;&gt; 1 &gt; 0) {</span>
 300 |     | <span class='neutral'>                result += 1;</span>
 301 |     | <span class='neutral'>            }</span>
 302 |     | <span class='neutral'>        }</span>
 303 |     | <span class='neutral'>        return result;</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    /**</span>
 307 |     | <span class='neutral'>     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.</span>
 308 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 309 |     | <span class='neutral'>     */</span>
 310 |     | <span class='neutral'>    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 311 |     | <span class='neutral'>        unchecked {</span>
 312 |     | <span class='neutral'>            uint256 result = log2(value);</span>
 313 |     | <span class='neutral'>            return result + (unsignedRoundsUp(rounding) &amp;&amp; 1 &lt;&lt; result &lt; value ? 1 : 0);</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>    /**</span>
 318 |     | <span class='neutral'>     * @dev Return the log in base 10 of a positive value rounded towards zero.</span>
 319 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 320 |     | <span class='neutral'>     */</span>
 321 | *   | <span class='executed'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 322 | *   | <span class='executed'>        uint256 result = 0;</span>
 323 |     | <span class='neutral'>        unchecked {</span>
 324 | *   | <span class='executed'>            if (value &gt;= 10 ** 64) {</span>
 325 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 326 |     | <span class='unexecuted'>                result += 64;</span>
 327 |     | <span class='neutral'>            }</span>
 328 | *   | <span class='executed'>            if (value &gt;= 10 ** 32) {</span>
 329 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 330 |     | <span class='unexecuted'>                result += 32;</span>
 331 |     | <span class='neutral'>            }</span>
 332 | *   | <span class='executed'>            if (value &gt;= 10 ** 16) {</span>
 333 | *   | <span class='executed'>                value /= 10 ** 16;</span>
 334 | *   | <span class='executed'>                result += 16;</span>
 335 |     | <span class='neutral'>            }</span>
 336 | *   | <span class='executed'>            if (value &gt;= 10 ** 8) {</span>
 337 | *   | <span class='executed'>                value /= 10 ** 8;</span>
 338 | *   | <span class='executed'>                result += 8;</span>
 339 |     | <span class='neutral'>            }</span>
 340 | *   | <span class='executed'>            if (value &gt;= 10 ** 4) {</span>
 341 | *   | <span class='executed'>                value /= 10 ** 4;</span>
 342 | *   | <span class='executed'>                result += 4;</span>
 343 |     | <span class='neutral'>            }</span>
 344 | *   | <span class='executed'>            if (value &gt;= 10 ** 2) {</span>
 345 | *   | <span class='executed'>                value /= 10 ** 2;</span>
 346 | *   | <span class='executed'>                result += 2;</span>
 347 |     | <span class='neutral'>            }</span>
 348 | *   | <span class='executed'>            if (value &gt;= 10 ** 1) {</span>
 349 | *   | <span class='executed'>                result += 1;</span>
 350 |     | <span class='neutral'>            }</span>
 351 |     | <span class='neutral'>        }</span>
 352 | *   | <span class='executed'>        return result;</span>
 353 |     | <span class='neutral'>    }</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='neutral'>    /**</span>
 356 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 357 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 358 |     | <span class='neutral'>     */</span>
 359 |     | <span class='neutral'>    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 360 |     | <span class='neutral'>        unchecked {</span>
 361 |     | <span class='neutral'>            uint256 result = log10(value);</span>
 362 |     | <span class='neutral'>            return result + (unsignedRoundsUp(rounding) &amp;&amp; 10 ** result &lt; value ? 1 : 0);</span>
 363 |     | <span class='neutral'>        }</span>
 364 |     | <span class='neutral'>    }</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='neutral'>    /**</span>
 367 |     | <span class='neutral'>     * @dev Return the log in base 256 of a positive value rounded towards zero.</span>
 368 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 369 |     | <span class='neutral'>     *</span>
 370 |     | <span class='neutral'>     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.</span>
 371 |     | <span class='neutral'>     */</span>
 372 |     | <span class='neutral'>    function log256(uint256 value) internal pure returns (uint256) {</span>
 373 |     | <span class='neutral'>        uint256 result = 0;</span>
 374 |     | <span class='neutral'>        unchecked {</span>
 375 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 376 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 377 |     | <span class='neutral'>                result += 16;</span>
 378 |     | <span class='neutral'>            }</span>
 379 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 380 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 381 |     | <span class='neutral'>                result += 8;</span>
 382 |     | <span class='neutral'>            }</span>
 383 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 384 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 385 |     | <span class='neutral'>                result += 4;</span>
 386 |     | <span class='neutral'>            }</span>
 387 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 388 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 389 |     | <span class='neutral'>                result += 2;</span>
 390 |     | <span class='neutral'>            }</span>
 391 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 392 |     | <span class='neutral'>                result += 1;</span>
 393 |     | <span class='neutral'>            }</span>
 394 |     | <span class='neutral'>        }</span>
 395 |     | <span class='neutral'>        return result;</span>
 396 |     | <span class='neutral'>    }</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>    /**</span>
 399 |     | <span class='neutral'>     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.</span>
 400 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 401 |     | <span class='neutral'>     */</span>
 402 |     | <span class='neutral'>    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 403 |     | <span class='neutral'>        unchecked {</span>
 404 |     | <span class='neutral'>            uint256 result = log256(value);</span>
 405 |     | <span class='neutral'>            return result + (unsignedRoundsUp(rounding) &amp;&amp; 1 &lt;&lt; (result &lt;&lt; 3) &lt; value ? 1 : 0);</span>
 406 |     | <span class='neutral'>        }</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    /**</span>
 410 |     | <span class='neutral'>     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.</span>
 411 |     | <span class='neutral'>     */</span>
 412 |     | <span class='neutral'>    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {</span>
 413 |     | <span class='neutral'>        return uint8(rounding) % 2 == 1;</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'>}</span>
 416 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Standard signed math utilities missing in the Solidity language.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>library SignedMath {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Returns the largest of two signed numbers.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    function max(int256 a, int256 b) internal pure returns (int256) {</span>
 14 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the smallest of two signed numbers.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function min(int256 a, int256 b) internal pure returns (int256) {</span>
 21 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the average of two signed numbers without overflow.</span>
 26 |     | <span class='neutral'>     * The result is rounded towards zero.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function average(int256 a, int256 b) internal pure returns (int256) {</span>
 29 |     | <span class='neutral'>        // Formula from the book &quot;Hacker&#39;s Delight&quot;</span>
 30 |     | <span class='neutral'>        int256 x = (a &amp; b) + ((a ^ b) &gt;&gt; 1);</span>
 31 |     | <span class='neutral'>        return x + (int256(uint256(x) &gt;&gt; 255) &amp; (a ^ b));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Returns the absolute unsigned value of a signed value.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        unchecked {</span>
 39 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 40 |     | <span class='neutral'>            return uint256(n &gt;= 0 ? n : -n);</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/properties/contracts/ERC4626/util/TestERC20Token.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;../../util/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract TestERC20Token is IERC20 {</span>
  7 |     | <span class='unexecuted'>    string public name;</span>
  8 |     | <span class='unexecuted'>    string public symbol;</span>
  9 |     | <span class='unexecuted'>    uint8 public decimals;</span>
 10 |     | <span class='unexecuted'>    uint256 public totalSupply;</span>
 11 | *   | <span class='executed'>    mapping(address =&gt; uint256) public balanceOf;</span>
 12 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
 13 |     | <span class='neutral'></span>
 14 | *   | <span class='executed'>    constructor(string memory _name, string memory _symbol, uint8 _decimals) {</span>
 15 | *   | <span class='executed'>        name = _name;</span>
 16 | *   | <span class='executed'>        symbol = _symbol;</span>
 17 | *   | <span class='executed'>        decimals = _decimals;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public returns (bool) {</span>
 21 | *   | <span class='executed'>        allowance[msg.sender][spender] = amount;</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>        emit Approval(msg.sender, spender, amount);</span>
 24 | *   | <span class='executed'>        return true;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function transfer(address to, uint256 amount) public returns (bool) {</span>
 28 | *   | <span class='executed'>        balanceOf[msg.sender] -= amount;</span>
 29 | *   | <span class='executed'>        balanceOf[to] += amount;</span>
 30 |     | <span class='neutral'></span>
 31 | *   | <span class='executed'>        emit Transfer(msg.sender, to, amount);</span>
 32 | *   | <span class='executed'>        return true;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>    function transferFrom(</span>
 36 |     | <span class='neutral'>        address from,</span>
 37 |     | <span class='neutral'>        address to,</span>
 38 |     | <span class='neutral'>        uint256 amount</span>
 39 | *   | <span class='executed'>    ) public returns (bool) {</span>
 40 | *   | <span class='executed'>        uint256 spenderAllowance = allowance[from][msg.sender];</span>
 41 | *   | <span class='executed'>        if (spenderAllowance != type(uint256).max) {</span>
 42 |     | <span class='unexecuted'>            allowance[from][msg.sender] = spenderAllowance - amount;</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'></span>
 45 | *   | <span class='executed'>        balanceOf[from] -= amount;</span>
 46 | *   | <span class='executed'>        balanceOf[to] += amount;</span>
 47 |     | <span class='neutral'></span>
 48 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 49 | *   | <span class='executed'>        return true;</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 | *   | <span class='executed'>    function mint(address to, uint256 amount) public {</span>
 53 | *   | <span class='executed'>        totalSupply += amount;</span>
 54 | *   | <span class='executed'>        balanceOf[to] += amount;</span>
 55 |     | <span class='neutral'></span>
 56 | *   | <span class='executed'>        emit Transfer(address(0), to, amount);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function burn(address from, uint256 amount) public {</span>
 60 |     | <span class='unexecuted'>        totalSupply -= amount;</span>
 61 |     | <span class='unexecuted'>        balanceOf[from] -= amount;</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>        emit Transfer(from, address(0), amount);</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>    function forceApproval(</span>
 67 |     | <span class='neutral'>        address account,</span>
 68 |     | <span class='neutral'>        address spender,</span>
 69 |     | <span class='neutral'>        uint256 amount</span>
 70 |     | <span class='neutral'>    ) public {</span>
 71 |     | <span class='unexecuted'>        allowance[account][spender] = amount;</span>
 72 |     | <span class='unexecuted'>        emit Approval(account, spender, amount);</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/properties/contracts/util/Hevm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IHevm {</span>
  5 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  6 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    // Set block.number to newNumber</span>
  9 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // Add the condition b to the assumption base for the current branch</span>
 12 |     | <span class='neutral'>    // This function is almost identical to require</span>
 13 |     | <span class='neutral'>    function assume(bool b) external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    // Sets the eth balance of usr to amt</span>
 16 |     | <span class='neutral'>    function deal(address usr, uint256 amt) external;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 19 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 22 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (v, r, s)</span>
 25 |     | <span class='neutral'>    function sign(</span>
 26 |     | <span class='neutral'>        uint256 privateKey,</span>
 27 |     | <span class='neutral'>        bytes32 digest</span>
 28 |     | <span class='neutral'>    ) external returns (uint8 v, bytes32 r, bytes32 s);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    // Gets address for a given private key</span>
 31 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address addr);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 34 |     | <span class='neutral'>    function ffi(</span>
 35 |     | <span class='neutral'>        string[] calldata inputs</span>
 36 |     | <span class='neutral'>    ) external returns (bytes memory result);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 39 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 42 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    // Takes a fork identifier created by createFork and sets the corresponding forked state as active</span>
 45 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    // Returns the identifier of the current fork</span>
 48 |     | <span class='neutral'>    function activeFork() external returns (uint256);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    // Labels the address in traces</span>
 51 |     | <span class='neutral'>    function label(address addr, string calldata label) external;</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/properties/contracts/util/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20 {</span>
  5 |     | <span class='neutral'>    /**</span>
  6 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
  7 |     | <span class='neutral'>     * another (`to`).</span>
  8 |     | <span class='neutral'>     *</span>
  9 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 10 |     | <span class='neutral'>     */</span>
 11 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 15 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    event Approval(</span>
 18 |     | <span class='neutral'>        address indexed owner,</span>
 19 |     | <span class='neutral'>        address indexed spender,</span>
 20 |     | <span class='neutral'>        uint256 value</span>
 21 |     | <span class='neutral'>    );</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /**</span>
 29 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 30 |     | <span class='neutral'>     */</span>
 31 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /**</span>
 34 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 35 |     | <span class='neutral'>     *</span>
 36 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 37 |     | <span class='neutral'>     *</span>
 38 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /**</span>
 43 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 44 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 45 |     | <span class='neutral'>     * zero by default.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 48 |     | <span class='neutral'>     */</span>
 49 |     | <span class='neutral'>    function allowance(</span>
 50 |     | <span class='neutral'>        address owner,</span>
 51 |     | <span class='neutral'>        address spender</span>
 52 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 58 |     | <span class='neutral'>     *</span>
 59 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 60 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 61 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 62 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 63 |     | <span class='neutral'>     * desired value afterwards:</span>
 64 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 65 |     | <span class='neutral'>     *</span>
 66 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 67 |     | <span class='neutral'>     */</span>
 68 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    /**</span>
 71 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 72 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 73 |     | <span class='neutral'>     * allowance.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 76 |     | <span class='neutral'>     *</span>
 77 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 78 |     | <span class='neutral'>     */</span>
 79 |     | <span class='neutral'>    function transferFrom(</span>
 80 |     | <span class='neutral'>        address from,</span>
 81 |     | <span class='neutral'>        address to,</span>
 82 |     | <span class='neutral'>        uint256 amount</span>
 83 |     | <span class='neutral'>    ) external returns (bool);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    function decimals() external returns (uint8);</span>
 86 |     | <span class='neutral'>}</span>
 87 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/lib/properties/contracts/util/PropertiesHelper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>abstract contract PropertiesAsserts {</span>
   5 |     | <span class='neutral'>    event LogUint256(string, uint256);</span>
   6 |     | <span class='neutral'>    event LogAddress(string, address);</span>
   7 |     | <span class='neutral'>    event LogString(string);</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    event AssertFail(string);</span>
  10 |     | <span class='neutral'>    event AssertEqFail(string);</span>
  11 |     | <span class='neutral'>    event AssertNeqFail(string);</span>
  12 |     | <span class='neutral'>    event AssertGteFail(string);</span>
  13 |     | <span class='neutral'>    event AssertGtFail(string);</span>
  14 |     | <span class='neutral'>    event AssertLteFail(string);</span>
  15 |     | <span class='neutral'>    event AssertLtFail(string);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    function assertWithMsg(bool b, string memory reason) internal {</span>
  18 |     | <span class='neutral'>        if (!b) {</span>
  19 |     | <span class='neutral'>            emit AssertFail(reason);</span>
  20 |     | <span class='neutral'>            assert(false);</span>
  21 |     | <span class='neutral'>        }</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    /// @notice asserts that a is equal to b. Violations are logged using reason.</span>
  25 | *   | <span class='executed'>    function assertEq(uint256 a, uint256 b, string memory reason) internal {</span>
  26 | *   | <span class='executed'>        if (a != b) {</span>
  27 | *   | <span class='executed'>            string memory aStr = PropertiesLibString.toString(a);</span>
  28 | *   | <span class='executed'>            string memory bStr = PropertiesLibString.toString(b);</span>
  29 | *   | <span class='executed'>            bytes memory assertMsg = abi.encodePacked(</span>
  30 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  31 | *   | <span class='executed'>                aStr,</span>
  32 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  33 | *   | <span class='executed'>                bStr,</span>
  34 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  35 | *   | <span class='executed'>                reason</span>
  36 |     | <span class='neutral'>            );</span>
  37 | *   | <span class='executed'>            emit AssertEqFail(string(assertMsg));</span>
  38 | *   | <span class='executed'>            assert(false);</span>
  39 |     | <span class='neutral'>        }</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice int256 version of assertEq</span>
  43 |     | <span class='neutral'>    function assertEq(int256 a, int256 b, string memory reason) internal {</span>
  44 |     | <span class='neutral'>        if (a != b) {</span>
  45 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  46 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  47 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  48 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  49 |     | <span class='neutral'>                aStr,</span>
  50 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  51 |     | <span class='neutral'>                bStr,</span>
  52 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  53 |     | <span class='neutral'>                reason</span>
  54 |     | <span class='neutral'>            );</span>
  55 |     | <span class='neutral'>            emit AssertEqFail(string(assertMsg));</span>
  56 |     | <span class='neutral'>            assert(false);</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice asserts that a is not equal to b. Violations are logged using reason.</span>
  61 |     | <span class='neutral'>    function assertNeq(uint256 a, uint256 b, string memory reason) internal {</span>
  62 |     | <span class='neutral'>        if (a == b) {</span>
  63 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  64 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  65 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  66 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  67 |     | <span class='neutral'>                aStr,</span>
  68 |     | <span class='neutral'>                &quot;==&quot;,</span>
  69 |     | <span class='neutral'>                bStr,</span>
  70 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  71 |     | <span class='neutral'>                reason</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  74 |     | <span class='neutral'>            assert(false);</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice int256 version of assertNeq</span>
  79 |     | <span class='neutral'>    function assertNeq(int256 a, int256 b, string memory reason) internal {</span>
  80 |     | <span class='neutral'>        if (a == b) {</span>
  81 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  82 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  83 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  84 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  85 |     | <span class='neutral'>                aStr,</span>
  86 |     | <span class='neutral'>                &quot;==&quot;,</span>
  87 |     | <span class='neutral'>                bStr,</span>
  88 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  89 |     | <span class='neutral'>                reason</span>
  90 |     | <span class='neutral'>            );</span>
  91 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  92 |     | <span class='neutral'>            assert(false);</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.</span>
  97 |     | <span class='neutral'>    function assertGte(uint256 a, uint256 b, string memory reason) internal {</span>
  98 |     | <span class='neutral'>        if (!(a &gt;= b)) {</span>
  99 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 100 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 101 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 102 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 103 |     | <span class='neutral'>                aStr,</span>
 104 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 105 |     | <span class='neutral'>                bStr,</span>
 106 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 107 |     | <span class='neutral'>                reason</span>
 108 |     | <span class='neutral'>            );</span>
 109 |     | <span class='neutral'>            emit AssertGteFail(string(assertMsg));</span>
 110 |     | <span class='neutral'>            assert(false);</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /// @notice int256 version of assertGte</span>
 115 |     | <span class='neutral'>    function assertGte(int256 a, int256 b, string memory reason) internal {</span>
 116 |     | <span class='neutral'>        if (!(a &gt;= b)) {</span>
 117 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 118 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 119 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 120 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 121 |     | <span class='neutral'>                aStr,</span>
 122 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 123 |     | <span class='neutral'>                bStr,</span>
 124 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 125 |     | <span class='neutral'>                reason</span>
 126 |     | <span class='neutral'>            );</span>
 127 |     | <span class='neutral'>            emit AssertGteFail(string(assertMsg));</span>
 128 |     | <span class='neutral'>            assert(false);</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /// @notice asserts that a is greater than b. Violations are logged using reason.</span>
 133 | *   | <span class='executed'>    function assertGt(uint256 a, uint256 b, string memory reason) internal {</span>
 134 | *   | <span class='executed'>        if (!(a &gt; b)) {</span>
 135 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
 136 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 137 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 138 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 139 |     | <span class='unexecuted'>                aStr,</span>
 140 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 141 |     | <span class='unexecuted'>                bStr,</span>
 142 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 143 |     | <span class='unexecuted'>                reason</span>
 144 |     | <span class='neutral'>            );</span>
 145 |     | <span class='unexecuted'>            emit AssertGtFail(string(assertMsg));</span>
 146 |     | <span class='unexecuted'>            assert(false);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    /// @notice int256 version of assertGt</span>
 151 |     | <span class='neutral'>    function assertGt(int256 a, int256 b, string memory reason) internal {</span>
 152 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 153 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 154 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 155 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 156 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 157 |     | <span class='neutral'>                aStr,</span>
 158 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 159 |     | <span class='neutral'>                bStr,</span>
 160 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 161 |     | <span class='neutral'>                reason</span>
 162 |     | <span class='neutral'>            );</span>
 163 |     | <span class='neutral'>            emit AssertGtFail(string(assertMsg));</span>
 164 |     | <span class='neutral'>            assert(false);</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /// @notice asserts that a is less than or equal to b. Violations are logged using reason.</span>
 169 |     | <span class='neutral'>    function assertLte(uint256 a, uint256 b, string memory reason) internal {</span>
 170 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 171 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 172 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 173 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 174 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 175 |     | <span class='neutral'>                aStr,</span>
 176 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 177 |     | <span class='neutral'>                bStr,</span>
 178 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 179 |     | <span class='neutral'>                reason</span>
 180 |     | <span class='neutral'>            );</span>
 181 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 182 |     | <span class='neutral'>            assert(false);</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /// @notice int256 version of assertLte</span>
 187 |     | <span class='neutral'>    function assertLte(int256 a, int256 b, string memory reason) internal {</span>
 188 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 189 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 190 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 191 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 192 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 193 |     | <span class='neutral'>                aStr,</span>
 194 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 195 |     | <span class='neutral'>                bStr,</span>
 196 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 197 |     | <span class='neutral'>                reason</span>
 198 |     | <span class='neutral'>            );</span>
 199 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 200 |     | <span class='neutral'>            assert(false);</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /// @notice asserts that a is less than b. Violations are logged using reason.</span>
 205 | *   | <span class='executed'>    function assertLt(uint256 a, uint256 b, string memory reason) internal {</span>
 206 | *   | <span class='executed'>        if (!(a &lt; b)) {</span>
 207 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
 208 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 209 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 210 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 211 |     | <span class='unexecuted'>                aStr,</span>
 212 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 213 |     | <span class='unexecuted'>                bStr,</span>
 214 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 215 |     | <span class='unexecuted'>                reason</span>
 216 |     | <span class='neutral'>            );</span>
 217 |     | <span class='unexecuted'>            emit AssertLtFail(string(assertMsg));</span>
 218 |     | <span class='unexecuted'>            assert(false);</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /// @notice int256 version of assertLt</span>
 223 |     | <span class='neutral'>    function assertLt(int256 a, int256 b, string memory reason) internal {</span>
 224 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 225 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 226 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 227 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 228 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 229 |     | <span class='neutral'>                aStr,</span>
 230 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 231 |     | <span class='neutral'>                bStr,</span>
 232 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 233 |     | <span class='neutral'>                reason</span>
 234 |     | <span class='neutral'>            );</span>
 235 |     | <span class='neutral'>            emit AssertLtFail(string(assertMsg));</span>
 236 |     | <span class='neutral'>            assert(false);</span>
 237 |     | <span class='neutral'>        }</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
 241 | *   | <span class='executed'>    function clampBetween(</span>
 242 |     | <span class='neutral'>        uint256 value,</span>
 243 |     | <span class='neutral'>        uint256 low,</span>
 244 |     | <span class='neutral'>        uint256 high</span>
 245 | *   | <span class='executed'>    ) internal returns (uint256) {</span>
 246 | *   | <span class='executed'>        if (value &lt; low || value &gt; high) {</span>
 247 | *   | <span class='executed'>            uint ans = low + (value % (high - low + 1));</span>
 248 | *   | <span class='executed'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 249 | *   | <span class='executed'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 250 | *   | <span class='executed'>            bytes memory message = abi.encodePacked(</span>
 251 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 252 | *   | <span class='executed'>                valueStr,</span>
 253 |     | <span class='neutral'>                &quot; to &quot;,</span>
 254 | *   | <span class='executed'>                ansStr</span>
 255 |     | <span class='neutral'>            );</span>
 256 | *   | <span class='executed'>            emit LogString(string(message));</span>
 257 | *   | <span class='executed'>            return ans;</span>
 258 |     | <span class='neutral'>        }</span>
 259 | *   | <span class='executed'>        return value;</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    /// @notice int256 version of clampBetween</span>
 263 |     | <span class='neutral'>    function clampBetween(</span>
 264 |     | <span class='neutral'>        int256 value,</span>
 265 |     | <span class='neutral'>        int256 low,</span>
 266 |     | <span class='neutral'>        int256 high</span>
 267 |     | <span class='neutral'>    ) internal returns (int256) {</span>
 268 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 269 |     | <span class='neutral'>            int range = high - low + 1;</span>
 270 |     | <span class='neutral'>            int clamped = (value - low) % (range);</span>
 271 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 272 |     | <span class='neutral'>            int ans = low + clamped;</span>
 273 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 274 |     | <span class='neutral'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 275 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 276 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 277 |     | <span class='neutral'>                valueStr,</span>
 278 |     | <span class='neutral'>                &quot; to &quot;,</span>
 279 |     | <span class='neutral'>                ansStr</span>
 280 |     | <span class='neutral'>            );</span>
 281 |     | <span class='neutral'>            emit LogString(string(message));</span>
 282 |     | <span class='neutral'>            return ans;</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>        return value;</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
 288 |     | <span class='neutral'>    function clampLt(uint256 a, uint256 b) internal returns (uint256) {</span>
 289 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 290 |     | <span class='neutral'>            assertNeq(</span>
 291 |     | <span class='neutral'>                b,</span>
 292 |     | <span class='neutral'>                0,</span>
 293 |     | <span class='neutral'>                &quot;clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.&quot;</span>
 294 |     | <span class='neutral'>            );</span>
 295 |     | <span class='neutral'>            uint256 value = a % b;</span>
 296 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 297 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 298 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 299 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 300 |     | <span class='neutral'>                aStr,</span>
 301 |     | <span class='neutral'>                &quot; to &quot;,</span>
 302 |     | <span class='neutral'>                valueStr</span>
 303 |     | <span class='neutral'>            );</span>
 304 |     | <span class='neutral'>            emit LogString(string(message));</span>
 305 |     | <span class='neutral'>            return value;</span>
 306 |     | <span class='neutral'>        }</span>
 307 |     | <span class='neutral'>        return a;</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
 311 |     | <span class='neutral'>    function clampLt(int256 a, int256 b) internal returns (int256) {</span>
 312 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 313 |     | <span class='neutral'>            int256 value = b - 1;</span>
 314 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 315 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 316 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 317 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 318 |     | <span class='neutral'>                aStr,</span>
 319 |     | <span class='neutral'>                &quot; to &quot;,</span>
 320 |     | <span class='neutral'>                valueStr</span>
 321 |     | <span class='neutral'>            );</span>
 322 |     | <span class='neutral'>            emit LogString(string(message));</span>
 323 |     | <span class='neutral'>            return value;</span>
 324 |     | <span class='neutral'>        }</span>
 325 |     | <span class='neutral'>        return a;</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 329 |     | <span class='neutral'>    function clampLte(uint256 a, uint256 b) internal returns (uint256) {</span>
 330 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 331 |     | <span class='neutral'>            uint256 value = a % (b + 1);</span>
 332 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 333 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 334 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 335 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 336 |     | <span class='neutral'>                aStr,</span>
 337 |     | <span class='neutral'>                &quot; to &quot;,</span>
 338 |     | <span class='neutral'>                valueStr</span>
 339 |     | <span class='neutral'>            );</span>
 340 |     | <span class='neutral'>            emit LogString(string(message));</span>
 341 |     | <span class='neutral'>            return value;</span>
 342 |     | <span class='neutral'>        }</span>
 343 |     | <span class='neutral'>        return a;</span>
 344 |     | <span class='neutral'>    }</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 347 |     | <span class='neutral'>    function clampLte(int256 a, int256 b) internal returns (int256) {</span>
 348 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 349 |     | <span class='neutral'>            int256 value = b;</span>
 350 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 351 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 352 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 353 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 354 |     | <span class='neutral'>                aStr,</span>
 355 |     | <span class='neutral'>                &quot; to &quot;,</span>
 356 |     | <span class='neutral'>                valueStr</span>
 357 |     | <span class='neutral'>            );</span>
 358 |     | <span class='neutral'>            emit LogString(string(message));</span>
 359 |     | <span class='neutral'>            return value;</span>
 360 |     | <span class='neutral'>        }</span>
 361 |     | <span class='neutral'>        return a;</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 365 |     | <span class='neutral'>    function clampGt(uint256 a, uint256 b) internal returns (uint256) {</span>
 366 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 367 |     | <span class='neutral'>            assertNeq(</span>
 368 |     | <span class='neutral'>                b,</span>
 369 |     | <span class='neutral'>                type(uint256).max,</span>
 370 |     | <span class='neutral'>                &quot;clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.&quot;</span>
 371 |     | <span class='neutral'>            );</span>
 372 |     | <span class='neutral'>            uint256 value = b + 1;</span>
 373 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 374 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 375 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 376 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 377 |     | <span class='neutral'>                aStr,</span>
 378 |     | <span class='neutral'>                &quot; to &quot;,</span>
 379 |     | <span class='neutral'>                valueStr</span>
 380 |     | <span class='neutral'>            );</span>
 381 |     | <span class='neutral'>            emit LogString(string(message));</span>
 382 |     | <span class='neutral'>            return value;</span>
 383 |     | <span class='neutral'>        } else {</span>
 384 |     | <span class='neutral'>            return a;</span>
 385 |     | <span class='neutral'>        }</span>
 386 |     | <span class='neutral'>    }</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 389 |     | <span class='neutral'>    function clampGt(int256 a, int256 b) internal returns (int256) {</span>
 390 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 391 |     | <span class='neutral'>            int256 value = b + 1;</span>
 392 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 393 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 394 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 395 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 396 |     | <span class='neutral'>                aStr,</span>
 397 |     | <span class='neutral'>                &quot; to &quot;,</span>
 398 |     | <span class='neutral'>                valueStr</span>
 399 |     | <span class='neutral'>            );</span>
 400 |     | <span class='neutral'>            emit LogString(string(message));</span>
 401 |     | <span class='neutral'>            return value;</span>
 402 |     | <span class='neutral'>        } else {</span>
 403 |     | <span class='neutral'>            return a;</span>
 404 |     | <span class='neutral'>        }</span>
 405 |     | <span class='neutral'>    }</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 408 |     | <span class='neutral'>    function clampGte(uint256 a, uint256 b) internal returns (uint256) {</span>
 409 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 410 |     | <span class='neutral'>            uint256 value = b;</span>
 411 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 412 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 413 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 414 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 415 |     | <span class='neutral'>                aStr,</span>
 416 |     | <span class='neutral'>                &quot; to &quot;,</span>
 417 |     | <span class='neutral'>                valueStr</span>
 418 |     | <span class='neutral'>            );</span>
 419 |     | <span class='neutral'>            emit LogString(string(message));</span>
 420 |     | <span class='neutral'>            return value;</span>
 421 |     | <span class='neutral'>        }</span>
 422 |     | <span class='neutral'>        return a;</span>
 423 |     | <span class='neutral'>    }</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 426 |     | <span class='neutral'>    function clampGte(int256 a, int256 b) internal returns (int256) {</span>
 427 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 428 |     | <span class='neutral'>            int256 value = b;</span>
 429 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 430 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 431 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 432 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 433 |     | <span class='neutral'>                aStr,</span>
 434 |     | <span class='neutral'>                &quot; to &quot;,</span>
 435 |     | <span class='neutral'>                valueStr</span>
 436 |     | <span class='neutral'>            );</span>
 437 |     | <span class='neutral'>            emit LogString(string(message));</span>
 438 |     | <span class='neutral'>            return value;</span>
 439 |     | <span class='neutral'>        }</span>
 440 |     | <span class='neutral'>        return a;</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'>}</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='neutral'>/// @notice Efficient library for creating string representations of integers.</span>
 445 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
 446 |     | <span class='neutral'>/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)</span>
 447 |     | <span class='neutral'>/// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString</span>
 448 |     | <span class='unexecuted'>library PropertiesLibString {</span>
 449 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory str) {</span>
 450 |     | <span class='neutral'>        uint256 absValue = value &gt;= 0 ? uint256(value) : uint256(-value);</span>
 451 |     | <span class='neutral'>        str = toString(absValue);</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>        if (value &lt; 0) {</span>
 454 |     | <span class='neutral'>            str = string(abi.encodePacked(&quot;-&quot;, str));</span>
 455 |     | <span class='neutral'>        }</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'></span>
 458 | *   | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
 459 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 460 | *   | <span class='executed'>        assembly {</span>
 461 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes</span>
 462 |     | <span class='neutral'>            // to keep the free memory pointer word aligned. We&#39;ll need 1 word for the length, 1 word for the</span>
 463 |     | <span class='neutral'>            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.</span>
 464 | *   | <span class='executed'>            let newFreeMemoryPointer := add(mload(0x40), 160)</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>            // Update the free memory pointer to avoid overriding our string.</span>
 467 | *   | <span class='executed'>            mstore(0x40, newFreeMemoryPointer)</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='neutral'>            // Assign str to the end of the zone of newly allocated memory.</span>
 470 | *   | <span class='executed'>            str := sub(newFreeMemoryPointer, 32)</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>            // Clean the last word of memory it may not be overwritten.</span>
 473 | *   | <span class='executed'>            mstore(str, 0)</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
 476 | *   | <span class='executed'>            let end := str</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
 479 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
 480 |     | <span class='neutral'>            // prettier-ignore</span>
 481 | *   | <span class='executed'>            for { let temp := value } 1 {} {</span>
 482 |     | <span class='neutral'>                // Move the pointer 1 byte to the left.</span>
 483 | *   | <span class='executed'>                str := sub(str, 1)</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='neutral'>                // Write the character to the pointer.</span>
 486 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
 487 | *   | <span class='executed'>                mstore8(str, add(48, mod(temp, 10)))</span>
 488 |     | <span class='neutral'></span>
 489 |     | <span class='neutral'>                // Keep dividing temp until zero.</span>
 490 | *   | <span class='executed'>                temp := div(temp, 10)</span>
 491 |     | <span class='neutral'></span>
 492 |     | <span class='neutral'>                 // prettier-ignore</span>
 493 | *   | <span class='executed'>                if iszero(temp) { break }</span>
 494 |     | <span class='neutral'>            }</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='neutral'>            // Compute and cache the final total length of the string.</span>
 497 | *   | <span class='executed'>            let length := sub(end, str)</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
 500 | *   | <span class='executed'>            str := sub(str, 32)</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='neutral'>            // Store the string&#39;s length at the start of memory allocated for our string.</span>
 503 | *   | <span class='executed'>            mstore(str, length)</span>
 504 |     | <span class='neutral'>        }</span>
 505 |     | <span class='neutral'>    }</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='neutral'>    function toString(address value) internal pure returns (string memory str) {</span>
 508 |     | <span class='neutral'>        bytes memory s = new bytes(40);</span>
 509 |     | <span class='neutral'>        for (uint i = 0; i &lt; 20; i++) {</span>
 510 |     | <span class='neutral'>            bytes1 b = bytes1(</span>
 511 |     | <span class='neutral'>                uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))</span>
 512 |     | <span class='neutral'>            );</span>
 513 |     | <span class='neutral'>            bytes1 hi = bytes1(uint8(b) / 16);</span>
 514 |     | <span class='neutral'>            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));</span>
 515 |     | <span class='neutral'>            s[2 * i] = char(hi);</span>
 516 |     | <span class='neutral'>            s[2 * i + 1] = char(lo);</span>
 517 |     | <span class='neutral'>        }</span>
 518 |     | <span class='neutral'>        return string(s);</span>
 519 |     | <span class='neutral'>    }</span>
 520 |     | <span class='neutral'></span>
 521 |     | <span class='neutral'>    function char(bytes1 b) internal pure returns (bytes1 c) {</span>
 522 |     | <span class='neutral'>        if (uint8(b) &lt; 10) return bytes1(uint8(b) + 0x30);</span>
 523 |     | <span class='neutral'>        else return bytes1(uint8(b) + 0x57);</span>
 524 |     | <span class='neutral'>    }</span>
 525 |     | <span class='neutral'>}</span>
 526 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/src/Staker.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/ReentrancyGuard.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Pausable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/access/AccessControl.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 | *   | <span class='executed'>contract Staker is AccessControl, ReentrancyGuard, Pausable {</span>
  11 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  12 |     | <span class='neutral'></span>
  13 | *   | <span class='executed'>    bytes32 public constant REWARDS_ADMIN_ROLE = keccak256(&quot;REWARDS_ADMIN_ROLE&quot;);</span>
  14 | *   | <span class='executed'>    bytes32 public constant PAUSE_GUARDIAN_ROLE = keccak256(&quot;PAUSE_GUARDIAN_ROLE&quot;);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    // Events</span>
  17 |     | <span class='neutral'>    event Staked(address indexed user, uint256 amount);</span>
  18 |     | <span class='neutral'>    event Withdrawn(address indexed user, uint256 amount);</span>
  19 |     | <span class='neutral'>    event RewardAdded(address indexed token, uint256 amount, uint256 duration);</span>
  20 |     | <span class='neutral'>    event RewardClaimed(address indexed user, address indexed token, uint256 amount);</span>
  21 |     | <span class='neutral'>    event RewardTokenRemoved(address indexed token);</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>    IERC20 public immutable stakingToken;</span>
  24 |     | <span class='unexecuted'>    IERC20[] public rewardTokens;</span>
  25 | *   | <span class='executed'>    mapping(address =&gt; bool) public isRewardToken;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    struct Reward {</span>
  28 |     | <span class='neutral'>        uint256 duration;</span>
  29 |     | <span class='neutral'>        uint256 rate;</span>
  30 |     | <span class='neutral'>        uint256 lastUpdateTime;</span>
  31 |     | <span class='neutral'>        uint256 rewardPerTokenStored;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 | *   | <span class='executed'>    mapping(address =&gt; Reward) public rewards;</span>
  35 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public userRewardPerTokenPaid;</span>
  36 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public rewardsEarned;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    uint256 private _totalStaked;</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _stakedBalances;</span>
  40 |     | <span class='neutral'></span>
  41 | *   | <span class='executed'>    uint256 private constant MAX_REWARD_DURATION = 3650 days; </span>
  42 |     | <span class='neutral'></span>
  43 | *   | <span class='executed'>    constructor(address _stakingToken, address _admin, address _pauseGuardian) {</span>
  44 | *   | <span class='executed'>        require(_stakingToken != address(0), &quot;Invalid staking token&quot;);</span>
  45 | *   | <span class='executed'>        require(_admin != address(0), &quot;Invalid admin address&quot;);</span>
  46 | *   | <span class='executed'>        require(_pauseGuardian != address(0), &quot;Invalid pause guardian&quot;);</span>
  47 |     | <span class='neutral'></span>
  48 | *   | <span class='executed'>        stakingToken = IERC20(_stakingToken);</span>
  49 | *   | <span class='executed'>        _grantRole(DEFAULT_ADMIN_ROLE, _admin);</span>
  50 | *   | <span class='executed'>        _grantRole(REWARDS_ADMIN_ROLE, _admin);</span>
  51 | *   | <span class='executed'>        _grantRole(PAUSE_GUARDIAN_ROLE, _pauseGuardian);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 | *   | <span class='executed'>    function stake(</span>
  55 |     | <span class='neutral'>        uint256 amount</span>
  56 |     | <span class='neutral'>    ) external nonReentrant whenNotPaused {</span>
  57 | *   | <span class='executed'>        require(amount &gt; 0, &quot;Cannot stake 0&quot;);</span>
  58 | *   | <span class='executed'>        _updateRewards(msg.sender);</span>
  59 |     | <span class='neutral'></span>
  60 | *   | <span class='executed'>        _totalStaked += amount;</span>
  61 | *   | <span class='executed'>        _stakedBalances[msg.sender] += amount;</span>
  62 |     | <span class='neutral'></span>
  63 | *   | <span class='executed'>        stakingToken.safeTransferFrom(msg.sender, address(this), amount);</span>
  64 | *   | <span class='executed'>        emit Staked(msg.sender, amount);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 | *   | <span class='executed'>    function withdraw(</span>
  68 |     | <span class='neutral'>        uint256 amount</span>
  69 |     | <span class='neutral'>    ) external nonReentrant whenNotPaused {</span>
  70 | *   | <span class='executed'>        require(amount &gt; 0, &quot;Cannot withdraw 0&quot;);</span>
  71 | *   | <span class='executed'>        require(_stakedBalances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span>
  72 | *   | <span class='executed'>        _updateRewards(msg.sender);</span>
  73 |     | <span class='neutral'></span>
  74 | *   | <span class='executed'>        _totalStaked -= amount;</span>
  75 | *   | <span class='executed'>        _stakedBalances[msg.sender] -= amount;</span>
  76 |     | <span class='neutral'></span>
  77 | *   | <span class='executed'>        stakingToken.safeTransfer(msg.sender, amount);</span>
  78 | *   | <span class='executed'>        emit Withdrawn(msg.sender, amount);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 | *   | <span class='executed'>    function claimRewards(</span>
  82 |     | <span class='neutral'>        address rewardToken</span>
  83 | *   | <span class='executed'>    ) external nonReentrant {</span>
  84 | *   | <span class='executed'>        require(rewards[rewardToken].duration &gt; 0, &quot;Invalid reward token&quot;);</span>
  85 | *   | <span class='executed'>        _updateRewards(msg.sender);</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>        uint256 reward = rewardsEarned[msg.sender][rewardToken];</span>
  88 | *   | <span class='executed'>        require(reward &gt; 0, &quot;No rewards to claim&quot;);</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>        rewardsEarned[msg.sender][rewardToken] = 0;</span>
  91 | *   | <span class='executed'>        IERC20(rewardToken).safeTransfer(msg.sender, reward);</span>
  92 | *   | <span class='executed'>        emit RewardClaimed(msg.sender, rewardToken, reward);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function addReward(</span>
  96 |     | <span class='neutral'>        address rewardToken,</span>
  97 |     | <span class='neutral'>        uint256 totalRewards,</span>
  98 |     | <span class='neutral'>        uint256 duration</span>
  99 | *   | <span class='executed'>    ) external onlyRole(REWARDS_ADMIN_ROLE) {</span>
 100 | *   | <span class='executed'>        require(rewardToken != address(0), &quot;Invalid reward token&quot;);</span>
 101 | *   | <span class='executed'>        require(totalRewards &gt; 0 &amp;&amp; duration &gt; 0, &quot;Invalid parameters&quot;);</span>
 102 | *   | <span class='executed'>        require(duration &lt;= MAX_REWARD_DURATION, &quot;Duration exceeds maximum&quot;);</span>
 103 |     | <span class='neutral'></span>
 104 | *   | <span class='executed'>        Reward storage reward = rewards[rewardToken];</span>
 105 | *   | <span class='executed'>        if (reward.duration &gt; 0) {</span>
 106 | *   | <span class='executed'>            require(block.timestamp &gt;= reward.lastUpdateTime + reward.duration, &quot;Previous reward ongoing&quot;);</span>
 107 | *   | <span class='executed'>            uint256 endTime = reward.lastUpdateTime + reward.duration;</span>
 108 | *   | <span class='executed'>            uint256 timeElapsed = endTime - reward.lastUpdateTime;</span>
 109 | *   | <span class='executed'>            if (_totalStaked &gt; 0) {</span>
 110 | *   | <span class='executed'>                reward.rewardPerTokenStored += (timeElapsed * reward.rate * 1e18) / _totalStaked;</span>
 111 |     | <span class='neutral'>            }</span>
 112 | *   | <span class='executed'>            reward.lastUpdateTime = endTime;</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'></span>
 115 | *   | <span class='executed'>        uint256 currentBalance = IERC20(rewardToken).balanceOf(address(this));</span>
 116 | *   | <span class='executed'>        require(totalRewards &gt;= currentBalance, &quot;Insufficient new rewards&quot;);</span>
 117 | *   | <span class='executed'>        uint256 amountToTransfer = totalRewards - currentBalance;</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>        if (!isRewardToken[rewardToken]) {</span>
 120 | *   | <span class='executed'>            rewardTokens.push(IERC20(rewardToken));</span>
 121 | *   | <span class='executed'>            isRewardToken[rewardToken] = true;</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>        uint256 rate = totalRewards / duration;</span>
 125 | *   | <span class='executed'>        reward.duration = duration;</span>
 126 | *   | <span class='executed'>        reward.rate = rate;</span>
 127 | *   | <span class='executed'>        reward.lastUpdateTime = block.timestamp;</span>
 128 |     | <span class='neutral'></span>
 129 | *   | <span class='executed'>        if (amountToTransfer &gt; 0) {</span>
 130 | *   | <span class='executed'>            IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amountToTransfer);</span>
 131 |     | <span class='neutral'>        }</span>
 132 | *   | <span class='executed'>        emit RewardAdded(rewardToken, totalRewards, duration);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>    function removeRewardToken(</span>
 136 |     | <span class='neutral'>        address rewardToken</span>
 137 |     | <span class='neutral'>    ) external onlyRole(REWARDS_ADMIN_ROLE) {</span>
 138 |     | <span class='unexecuted'>        require(isRewardToken[rewardToken], &quot;Not a reward token&quot;);</span>
 139 |     | <span class='unexecuted'>        require(</span>
 140 |     | <span class='unexecuted'>            block.timestamp &gt;= rewards[rewardToken].lastUpdateTime + rewards[rewardToken].duration, &quot;Reward ongoing&quot;</span>
 141 |     | <span class='neutral'>        );</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        isRewardToken[rewardToken] = false;</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; rewardTokens.length; i++) {</span>
 146 |     | <span class='unexecuted'>            if (address(rewardTokens[i]) == rewardToken) {</span>
 147 |     | <span class='unexecuted'>                rewardTokens[i] = rewardTokens[rewardTokens.length - 1];</span>
 148 |     | <span class='unexecuted'>                rewardTokens.pop();</span>
 149 |     | <span class='unexecuted'>                break;</span>
 150 |     | <span class='neutral'>            }</span>
 151 |     | <span class='neutral'>        }</span>
 152 |     | <span class='unexecuted'>        emit RewardTokenRemoved(rewardToken);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 | *   | <span class='executed'>    function _updateRewards(</span>
 156 |     | <span class='neutral'>        address user</span>
 157 |     | <span class='neutral'>    ) internal {</span>
 158 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; rewardTokens.length; i++) {</span>
 159 | *   | <span class='executed'>            address token = address(rewardTokens[i]);</span>
 160 | *   | <span class='executed'>            if (!isRewardToken[token]) continue;</span>
 161 |     | <span class='neutral'></span>
 162 | *   | <span class='executed'>            Reward storage reward = rewards[token];</span>
 163 | *   | <span class='executed'>            reward.rewardPerTokenStored = _rewardPerToken(token);</span>
 164 | *   | <span class='executed'>            reward.lastUpdateTime = lastTimeRewardApplicable(token);</span>
 165 |     | <span class='neutral'></span>
 166 | *   | <span class='executed'>            if (user != address(0)) {</span>
 167 | *   | <span class='executed'>                rewardsEarned[user][token] = earned(user, token);</span>
 168 | *   | <span class='executed'>                userRewardPerTokenPaid[user][token] = reward.rewardPerTokenStored;</span>
 169 |     | <span class='neutral'>            }</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 | *   | <span class='executed'>    function lastTimeRewardApplicable(</span>
 174 |     | <span class='neutral'>        address rewardToken</span>
 175 | *   | <span class='executed'>    ) public view returns (uint256) {</span>
 176 | *   | <span class='executed'>        Reward storage reward = rewards[rewardToken];</span>
 177 | *   | <span class='executed'>        return block.timestamp &lt; reward.lastUpdateTime + reward.duration</span>
 178 | *   | <span class='executed'>            ? block.timestamp</span>
 179 | *   | <span class='executed'>            : reward.lastUpdateTime + reward.duration;</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 | *   | <span class='executed'>    function _rewardPerToken(</span>
 183 |     | <span class='neutral'>        address rewardToken</span>
 184 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 185 | *   | <span class='executed'>        Reward storage reward = rewards[rewardToken];</span>
 186 | *   | <span class='executed'>        if (_totalStaked == 0) return reward.rewardPerTokenStored;</span>
 187 |     | <span class='neutral'></span>
 188 | *   | <span class='executed'>        uint256 timeElapsed = lastTimeRewardApplicable(rewardToken) - reward.lastUpdateTime;</span>
 189 | *   | <span class='executed'>        return reward.rewardPerTokenStored + (timeElapsed * reward.rate * 1e18) / _totalStaked;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 | *   | <span class='executed'>    function earned(address user, address rewardToken) public view returns (uint256) {</span>
 193 | *   | <span class='executed'>        uint256 currentRewardPerToken = _rewardPerToken(rewardToken);</span>
 194 | *   | <span class='executed'>        uint256 paid = userRewardPerTokenPaid[user][rewardToken];</span>
 195 | *   | <span class='executed'>        if (currentRewardPerToken &lt; paid) return rewardsEarned[user][rewardToken];</span>
 196 |     | <span class='neutral'></span>
 197 | *   | <span class='executed'>        uint256 delta = currentRewardPerToken - paid;</span>
 198 | *   | <span class='executed'>        uint256 newRewards = (_stakedBalances[user] * delta) / 1e18;</span>
 199 | *   | <span class='executed'>        return newRewards + rewardsEarned[user][rewardToken];</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 | *   | <span class='executed'>    function totalStaked() external view returns (uint256) {</span>
 203 | *   | <span class='executed'>        return _totalStaked;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 | *   | <span class='executed'>    function stakedBalanceOf(</span>
 207 |     | <span class='neutral'>        address user</span>
 208 | *   | <span class='executed'>    ) external view returns (uint256) {</span>
 209 | *   | <span class='executed'>        return _stakedBalances[user];</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 | *   | <span class='executed'>    function claimAllRewards() external nonReentrant {</span>
 213 | *   | <span class='executed'>        _updateRewards(msg.sender);</span>
 214 |     | <span class='neutral'></span>
 215 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; rewardTokens.length; i++) {</span>
 216 | *   | <span class='executed'>            address token = address(rewardTokens[i]);</span>
 217 | *   | <span class='executed'>            uint256 reward = rewardsEarned[msg.sender][token];</span>
 218 | *   | <span class='executed'>            if (reward &gt; 0) {</span>
 219 | *   | <span class='executed'>                rewardsEarned[msg.sender][token] = 0;</span>
 220 | *   | <span class='executed'>                IERC20(token).safeTransfer(msg.sender, reward);</span>
 221 | *   | <span class='executed'>                emit RewardClaimed(msg.sender, token, reward);</span>
 222 |     | <span class='neutral'>            }</span>
 223 |     | <span class='neutral'>        }</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'>}</span>
 226 |     | <span class='neutral'></span>

</code>
<br />

<b>/workspaces/codespaces-blank/Malo-Labs/contracts/test/EchidnaTesting/E2E.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {PropertiesAsserts} from &quot;properties/util/PropertiesHelper.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Strings} from &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import {TestERC20Token} from &quot;properties/ERC4626/util/TestERC20Token.sol&quot;;</span>
   8 |     | <span class='neutral'>import {IERC20} from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   9 |     | <span class='neutral'>import {Staker} from &quot;../../src/Staker.sol&quot;;</span>
  10 |     | <span class='neutral'>import {IHevm} from &quot;properties/util/Hevm.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/*</span>
  13 |     | <span class='neutral'>SOLC_VERSION=0.8.20 echidna ./test/EchidnaTesting/E2E.sol \</span>
  14 |     | <span class='neutral'>  --contract E2E \</span>
  15 |     | <span class='neutral'>  --config ./test/EchidnaTesting/echidna.yaml \</span>
  16 |     | <span class='neutral'>  --workers 10</span>
  17 |     | <span class='neutral'> */</span>
  18 |     | <span class='neutral'></span>
  19 | *   | <span class='executed'>contract StakerActor {</span>
  20 |     | <span class='unexecuted'>    Staker public immutable staker;</span>
  21 |     | <span class='unexecuted'>    IERC20 public immutable stakingToken;</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>    constructor(</span>
  24 |     | <span class='neutral'>        Staker _staker</span>
  25 |     | <span class='neutral'>    ) {</span>
  26 | *   | <span class='executed'>        staker = _staker;</span>
  27 | *   | <span class='executed'>        stakingToken = IERC20(staker.stakingToken());</span>
  28 | *   | <span class='executed'>        stakingToken.approve(address(staker), type(uint256).max);</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>    function stake(</span>
  32 |     | <span class='neutral'>        uint256 amount</span>
  33 |     | <span class='neutral'>    ) external {</span>
  34 | *   | <span class='executed'>        staker.stake(amount);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 | *   | <span class='executed'>    function withdraw(</span>
  38 |     | <span class='neutral'>        uint256 amount</span>
  39 |     | <span class='neutral'>    ) external {</span>
  40 | *   | <span class='executed'>        staker.withdraw(amount);</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 | *   | <span class='executed'>    function claimRewards(</span>
  44 |     | <span class='neutral'>        address rewardToken</span>
  45 |     | <span class='neutral'>    ) external {</span>
  46 | *   | <span class='executed'>        staker.claimRewards(rewardToken);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>    function claimAllRewards() external {</span>
  50 | *   | <span class='executed'>        staker.claimAllRewards();</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'>}</span>
  53 |     | <span class='neutral'></span>
  54 | *r  | <span class='executed'>contract E2E is PropertiesAsserts {</span>
  55 |     | <span class='neutral'>    using Strings for uint256;</span>
  56 |     | <span class='neutral'></span>
  57 | *   | <span class='executed'>    IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    Staker public staker;</span>
  60 |     | <span class='unexecuted'>    TestERC20Token public stakingToken;</span>
  61 |     | <span class='unexecuted'>    TestERC20Token public rewardToken1;</span>
  62 |     | <span class='unexecuted'>    TestERC20Token public rewardToken2;</span>
  63 |     | <span class='neutral'></span>
  64 | *   | <span class='executed'>    address constant ADMIN = address(0x1001);</span>
  65 | *   | <span class='executed'>    address constant PAUSE_GUARDIAN = address(0x1002);</span>
  66 | *   | <span class='executed'>    uint256 constant INITIAL_BALANCE = 1000 ether;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    StakerActor[] public actors;</span>
  69 | *   | <span class='executed'>    uint256 public constant START_TIMESTAMP = 1_706_745_600;</span>
  70 | *   | <span class='executed'>    uint256 public constant START_BLOCK = 17_336_000;</span>
  71 |     | <span class='neutral'></span>
  72 | *   | <span class='executed'>    constructor() {</span>
  73 | *   | <span class='executed'>        hevm.warp(START_TIMESTAMP);</span>
  74 | *   | <span class='executed'>        hevm.roll(START_BLOCK);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // Deploy tokens</span>
  77 | *   | <span class='executed'>        stakingToken = new TestERC20Token(&quot;Staking Token&quot;, &quot;STK&quot;, 18);</span>
  78 | *   | <span class='executed'>        rewardToken1 = new TestERC20Token(&quot;Reward Token 1&quot;, &quot;RWD1&quot;, 18);</span>
  79 | *   | <span class='executed'>        rewardToken2 = new TestERC20Token(&quot;Reward Token 2&quot;, &quot;RWD2&quot;, 18);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // Deploy staker</span>
  82 | *   | <span class='executed'>        staker = new Staker(address(stakingToken), ADMIN, PAUSE_GUARDIAN);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // Create actors</span>
  85 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; 3; i++) {</span>
  86 | *   | <span class='executed'>            actors.push(new StakerActor(staker));</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // Fund actors</span>
  90 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
  91 | *   | <span class='executed'>            address actor = address(actors[i]);</span>
  92 | *   | <span class='executed'>            stakingToken.mint(actor, INITIAL_BALANCE);</span>
  93 | *   | <span class='executed'>            rewardToken1.mint(actor, INITIAL_BALANCE);</span>
  94 | *   | <span class='executed'>            rewardToken2.mint(actor, INITIAL_BALANCE);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // Setup rewards</span>
  98 | *   | <span class='executed'>        rewardToken1.mint(ADMIN, 100_000 ether);</span>
  99 | *   | <span class='executed'>        rewardToken2.mint(ADMIN, 100_000 ether);</span>
 100 |     | <span class='neutral'></span>
 101 | *   | <span class='executed'>        hevm.prank(ADMIN);</span>
 102 | *   | <span class='executed'>        rewardToken1.approve(address(staker), type(uint256).max);</span>
 103 |     | <span class='neutral'></span>
 104 | *   | <span class='executed'>        hevm.prank(ADMIN);</span>
 105 | *   | <span class='executed'>        rewardToken2.approve(address(staker), type(uint256).max);</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>        hevm.prank(ADMIN);</span>
 108 | *   | <span class='executed'>        staker.addReward(address(rewardToken1), 1000 ether, 365 days);</span>
 109 |     | <span class='neutral'></span>
 110 | *   | <span class='executed'>        hevm.prank(ADMIN);</span>
 111 | *   | <span class='executed'>        staker.addReward(address(rewardToken2), 1000 ether, 365 days);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /* ================================================================</span>
 115 |     | <span class='neutral'>                            Echidna invariants</span>
 116 |     | <span class='neutral'>       ================================================================ */</span>
 117 |     | <span class='unexecuted'>    function echidna_total_staked_matches_sum() public view returns (bool) {</span>
 118 |     | <span class='unexecuted'>        uint256 sum;</span>
 119 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 120 |     | <span class='unexecuted'>            sum += staker.stakedBalanceOf(address(actors[i]));</span>
 121 |     | <span class='neutral'>        }</span>
 122 |     | <span class='unexecuted'>        return staker.totalStaked() == sum;</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>    function echidna_staking_token_balance_consistent() public view returns (bool) {</span>
 126 |     | <span class='unexecuted'>        return stakingToken.balanceOf(address(staker)) == staker.totalStaked();</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function echidna_reward_rate_nonzero_during_active_period() public view returns (bool) {</span>
 130 |     | <span class='unexecuted'>        (uint256 duration1,,,) = staker.rewards(address(rewardToken1));</span>
 131 |     | <span class='unexecuted'>        (uint256 duration2,,,) = staker.rewards(address(rewardToken2));</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        return duration1 &gt; 0 &amp;&amp; duration2 &gt; 0;</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>    function echidna_no_negative_balances() public view returns (bool) {</span>
 137 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 138 |     | <span class='unexecuted'>            if (staker.stakedBalanceOf(address(actors[i])) &gt; INITIAL_BALANCE) {</span>
 139 |     | <span class='unexecuted'>                return false;</span>
 140 |     | <span class='neutral'>            }</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='unexecuted'>        return true;</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>    function echidna_stakingIsConsistent() public view returns (bool success) {</span>
 146 |     | <span class='neutral'>        // Check that the sum of all user staked balances matches totalStaked</span>
 147 |     | <span class='unexecuted'>        uint256 sum;</span>
 148 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 149 |     | <span class='unexecuted'>            address actor = address(actors[i]);</span>
 150 |     | <span class='unexecuted'>            sum += staker.stakedBalanceOf(actor);</span>
 151 |     | <span class='neutral'>        }</span>
 152 |     | <span class='unexecuted'>        if (sum != staker.totalStaked()) return false;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        // Optionally, check that reward tokens are registered and earned is non-negative</span>
 155 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 156 |     | <span class='unexecuted'>            address actor = address(actors[i]);</span>
 157 |     | <span class='unexecuted'>            for (uint256 j = 0; j &lt; 2; j++) {</span>
 158 |     | <span class='unexecuted'>                address rewardToken = j == 0 ? address(rewardToken1) : address(rewardToken2);</span>
 159 |     | <span class='unexecuted'>                if (!staker.isRewardToken(rewardToken)) return false;</span>
 160 |     | <span class='neutral'>                // earned should never underflow</span>
 161 |     | <span class='unexecuted'>                if (staker.earned(actor, rewardToken) &lt; 0) return false;</span>
 162 |     | <span class='neutral'>            }</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        return true;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    /* ================================================================</span>
 169 |     | <span class='neutral'>                            Functions used for system interaction</span>
 170 |     | <span class='neutral'>       ================================================================ */</span>
 171 | *   | <span class='executed'>    function stake(uint8 actorIndex, uint256 amount) public {</span>
 172 | *   | <span class='executed'>        emit LogUint256(&quot;[stake] block.timestamp:&quot;, block.timestamp);</span>
 173 |     | <span class='neutral'></span>
 174 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 175 | *   | <span class='executed'>        amount = clampBetween(amount, 1, stakingToken.balanceOf(address(actors[actorIndex])));</span>
 176 |     | <span class='neutral'></span>
 177 | *   | <span class='executed'>        uint256 preStaked = staker.stakedBalanceOf(address(actors[actorIndex]));</span>
 178 | *   | <span class='executed'>        uint256 preTotal = staker.totalStaked();</span>
 179 |     | <span class='neutral'></span>
 180 | *   | <span class='executed'>        actors[actorIndex].stake(amount);</span>
 181 |     | <span class='neutral'></span>
 182 | *   | <span class='executed'>        emit LogString(string.concat(&quot;Staked &quot;, amount.toString(), &quot; tokens by actor &quot;, uint256(actorIndex).toString()));</span>
 183 |     | <span class='neutral'></span>
 184 | *   | <span class='executed'>        assertEq(staker.stakedBalanceOf(address(actors[actorIndex])), preStaked + amount, &quot;Staked balance mismatch&quot;);</span>
 185 | *   | <span class='executed'>        assertEq(staker.totalStaked(), preTotal + amount, &quot;Total staked mismatch&quot;);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 | *   | <span class='executed'>    function withdraw(uint8 actorIndex, uint256 amount) public {</span>
 189 | *   | <span class='executed'>        emit LogUint256(&quot;[withdraw] block.timestamp:&quot;, block.timestamp);</span>
 190 |     | <span class='neutral'></span>
 191 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 192 | *   | <span class='executed'>        uint256 userStaked = staker.stakedBalanceOf(address(actors[actorIndex]));</span>
 193 | *   | <span class='executed'>        amount = clampBetween(amount, 1, userStaked);</span>
 194 |     | <span class='neutral'></span>
 195 | *   | <span class='executed'>        uint256 preStaked = userStaked;</span>
 196 | *   | <span class='executed'>        uint256 preTotal = staker.totalStaked();</span>
 197 | *   | <span class='executed'>        uint256 preBalance = stakingToken.balanceOf(address(actors[actorIndex]));</span>
 198 |     | <span class='neutral'></span>
 199 | *   | <span class='executed'>        actors[actorIndex].withdraw(amount);</span>
 200 |     | <span class='neutral'></span>
 201 | *   | <span class='executed'>        emit LogString(</span>
 202 | *   | <span class='executed'>            string.concat(&quot;Withdrew &quot;, amount.toString(), &quot; tokens by actor &quot;, uint256(actorIndex).toString())</span>
 203 |     | <span class='neutral'>        );</span>
 204 |     | <span class='neutral'></span>
 205 | *   | <span class='executed'>        assertEq(staker.stakedBalanceOf(address(actors[actorIndex])), preStaked - amount, &quot;Staked balance mismatch&quot;);</span>
 206 | *   | <span class='executed'>        assertEq(staker.totalStaked(), preTotal - amount, &quot;Total staked mismatch&quot;);</span>
 207 | *   | <span class='executed'>        assertEq(stakingToken.balanceOf(address(actors[actorIndex])), preBalance + amount, &quot;Token balance mismatch&quot;);</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 | *   | <span class='executed'>    function claimRewards(uint8 actorIndex, uint8 tokenIndex) public {</span>
 211 | *   | <span class='executed'>        emit LogUint256(&quot;[claimRewards] block.timestamp:&quot;, block.timestamp);</span>
 212 |     | <span class='neutral'></span>
 213 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 214 | *   | <span class='executed'>        tokenIndex = uint8(clampBetween(tokenIndex, 0, 1));</span>
 215 | *   | <span class='executed'>        address rewardToken = tokenIndex == 0 ? address(rewardToken1) : address(rewardToken2);</span>
 216 |     | <span class='neutral'></span>
 217 | *   | <span class='executed'>        uint256 earned = staker.earned(address(actors[actorIndex]), rewardToken);</span>
 218 | *   | <span class='executed'>        if (earned == 0) return;</span>
 219 |     | <span class='neutral'></span>
 220 | *   | <span class='executed'>        uint256 preBalance = IERC20(rewardToken).balanceOf(address(actors[actorIndex]));</span>
 221 | *r  | <span class='executed'>        actors[actorIndex].claimRewards(rewardToken);</span>
 222 |     | <span class='neutral'></span>
 223 | *   | <span class='executed'>        emit LogString(</span>
 224 | *   | <span class='executed'>            string.concat(&quot;Claimed &quot;, earned.toString(), &quot; rewards by actor &quot;, uint256(actorIndex).toString())</span>
 225 |     | <span class='neutral'>        );</span>
 226 |     | <span class='neutral'></span>
 227 | *   | <span class='executed'>        assertEq(</span>
 228 | *   | <span class='executed'>            IERC20(rewardToken).balanceOf(address(actors[actorIndex])), preBalance + earned, &quot;Reward claim mismatch&quot;</span>
 229 |     | <span class='neutral'>        );</span>
 230 | *   | <span class='executed'>        assertEq(staker.earned(address(actors[actorIndex]), rewardToken), 0, &quot;Rewards not reset&quot;);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 | *   | <span class='executed'>    function claimAllRewards(</span>
 234 |     | <span class='neutral'>        uint8 actorIndex</span>
 235 | *   | <span class='executed'>    ) public {</span>
 236 | *   | <span class='executed'>        emit LogUint256(&quot;[claimAllRewards] block.timestamp:&quot;, block.timestamp);</span>
 237 |     | <span class='neutral'></span>
 238 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 239 |     | <span class='neutral'></span>
 240 | *   | <span class='executed'>        uint256 earned1 = staker.earned(address(actors[actorIndex]), address(rewardToken1));</span>
 241 | *   | <span class='executed'>        uint256 earned2 = staker.earned(address(actors[actorIndex]), address(rewardToken2));</span>
 242 | *   | <span class='executed'>        uint256 preBalance1 = rewardToken1.balanceOf(address(actors[actorIndex]));</span>
 243 | *   | <span class='executed'>        uint256 preBalance2 = rewardToken2.balanceOf(address(actors[actorIndex]));</span>
 244 |     | <span class='neutral'></span>
 245 | *r  | <span class='executed'>        actors[actorIndex].claimAllRewards();</span>
 246 |     | <span class='neutral'></span>
 247 | *   | <span class='executed'>        emit LogString(string.concat(&quot;Claimed all rewards by actor &quot;, uint256(actorIndex).toString()));</span>
 248 |     | <span class='neutral'></span>
 249 | *   | <span class='executed'>        if (earned1 &gt; 0) {</span>
 250 | *   | <span class='executed'>            assertEq(</span>
 251 | *   | <span class='executed'>                rewardToken1.balanceOf(address(actors[actorIndex])), preBalance1 + earned1, &quot;Token1 claim mismatch&quot;</span>
 252 |     | <span class='neutral'>            );</span>
 253 |     | <span class='neutral'>        }</span>
 254 | *   | <span class='executed'>        if (earned2 &gt; 0) {</span>
 255 | *   | <span class='executed'>            assertEq(</span>
 256 | *   | <span class='executed'>                rewardToken2.balanceOf(address(actors[actorIndex])), preBalance2 + earned2, &quot;Token2 claim mismatch&quot;</span>
 257 |     | <span class='neutral'>            );</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 | *   | <span class='executed'>    function addReward(uint8 tokenIndex, uint256 totalRewards, uint256 duration) public {</span>
 262 | *   | <span class='executed'>        emit LogUint256(&quot;[addReward] block.timestamp:&quot;, block.timestamp);</span>
 263 |     | <span class='neutral'></span>
 264 | *   | <span class='executed'>        tokenIndex = uint8(clampBetween(tokenIndex, 0, 1));</span>
 265 | *   | <span class='executed'>        address rewardToken = tokenIndex == 0 ? address(rewardToken1) : address(rewardToken2);</span>
 266 | *   | <span class='executed'>        totalRewards = clampBetween(totalRewards, 1, 1000 ether);</span>
 267 | *   | <span class='executed'>        duration = clampBetween(duration, 1 days, 365 days);</span>
 268 |     | <span class='neutral'></span>
 269 | *   | <span class='executed'>        hevm.prank(ADMIN);</span>
 270 | *r  | <span class='executed'>        staker.addReward(rewardToken, totalRewards, duration);</span>
 271 |     | <span class='neutral'></span>
 272 | *   | <span class='executed'>        emit LogString(</span>
 273 | *   | <span class='executed'>            string.concat(</span>
 274 |     | <span class='neutral'>                &quot;Added reward: token=&quot;,</span>
 275 | *   | <span class='executed'>                Strings.toHexString(rewardToken),</span>
 276 |     | <span class='neutral'>                &quot; amount=&quot;,</span>
 277 | *   | <span class='executed'>                totalRewards.toString(),</span>
 278 |     | <span class='neutral'>                &quot; duration=&quot;,</span>
 279 | *   | <span class='executed'>                duration.toString()</span>
 280 |     | <span class='neutral'>            )</span>
 281 |     | <span class='neutral'>        );</span>
 282 |     | <span class='neutral'></span>
 283 | *   | <span class='executed'>        (uint256 rewardDuration,,,) = staker.rewards(rewardToken);</span>
 284 | *   | <span class='executed'>        assertEq(rewardDuration, duration, &quot;Duration mismatch&quot;);</span>
 285 | *   | <span class='executed'>        require(staker.isRewardToken(rewardToken), &quot;Token not registered&quot;);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 | *   | <span class='executed'>    function warp(</span>
 289 |     | <span class='neutral'>        uint256 timeJump</span>
 290 |     | <span class='neutral'>    ) public {</span>
 291 | *   | <span class='executed'>        timeJump = clampBetween(timeJump, 1 days, 365 days);</span>
 292 | *   | <span class='executed'>        hevm.warp(block.timestamp + timeJump);</span>
 293 | *   | <span class='executed'>        emit LogString(string.concat(&quot;Warped &quot;, timeJump.toString(), &quot; seconds&quot;));</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    /* ================================================================</span>
 297 |     | <span class='neutral'>                            Properties:</span>
 298 |     | <span class='neutral'>            checking if max* functions are aligned with ERC4626</span>
 299 |     | <span class='neutral'>       ================================================================ */</span>
 300 | *   | <span class='executed'>    function maxStake_correctMax(</span>
 301 |     | <span class='neutral'>        uint8 actorIndex</span>
 302 | *   | <span class='executed'>    ) public {</span>
 303 | *   | <span class='executed'>        emit LogUint256(&quot;[maxStake_correctMax] block.timestamp:&quot;, block.timestamp);</span>
 304 |     | <span class='neutral'></span>
 305 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 306 | *   | <span class='executed'>        uint256 maxAmount = stakingToken.balanceOf(address(actors[actorIndex]));</span>
 307 | *r  | <span class='executed'>        require(maxAmount &gt; 0, &quot;Max stake is zero&quot;);</span>
 308 |     | <span class='neutral'></span>
 309 | *   | <span class='executed'>        uint256 preStaked = staker.stakedBalanceOf(address(actors[actorIndex]));</span>
 310 | *   | <span class='executed'>        uint256 preTotal = staker.totalStaked();</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        actors[actorIndex].stake(maxAmount);</span>
 313 |     | <span class='neutral'></span>
 314 | *   | <span class='executed'>        assertEq(staker.stakedBalanceOf(address(actors[actorIndex])), preStaked + maxAmount, &quot;Staked balance mismatch&quot;);</span>
 315 | *   | <span class='executed'>        assertEq(staker.totalStaked(), preTotal + maxAmount, &quot;Total staked mismatch&quot;);</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='neutral'></span>
 318 | *   | <span class='executed'>    function maxWithdraw_correctMax(</span>
 319 |     | <span class='neutral'>        uint8 actorIndex</span>
 320 | *   | <span class='executed'>    ) public {</span>
 321 | *   | <span class='executed'>        emit LogUint256(&quot;[maxWithdraw_correctMax] block.timestamp:&quot;, block.timestamp);</span>
 322 |     | <span class='neutral'></span>
 323 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 324 | *   | <span class='executed'>        uint256 maxAmount = staker.stakedBalanceOf(address(actors[actorIndex]));</span>
 325 | *r  | <span class='executed'>        require(maxAmount &gt; 0, &quot;Max withdraw is zero&quot;);</span>
 326 |     | <span class='neutral'></span>
 327 | *   | <span class='executed'>        uint256 preStaked = maxAmount;</span>
 328 | *   | <span class='executed'>        uint256 preTotal = staker.totalStaked();</span>
 329 | *   | <span class='executed'>        uint256 preBalance = stakingToken.balanceOf(address(actors[actorIndex]));</span>
 330 |     | <span class='neutral'></span>
 331 | *   | <span class='executed'>        actors[actorIndex].withdraw(maxAmount);</span>
 332 |     | <span class='neutral'></span>
 333 | *   | <span class='executed'>        assertEq(staker.stakedBalanceOf(address(actors[actorIndex])), 0, &quot;Staked balance should be zero&quot;);</span>
 334 | *   | <span class='executed'>        assertEq(staker.totalStaked(), preTotal - preStaked, &quot;Total staked mismatch&quot;);</span>
 335 | *   | <span class='executed'>        assertEq(stakingToken.balanceOf(address(actors[actorIndex])), preBalance + preStaked, &quot;Token balance mismatch&quot;);</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 | *   | <span class='executed'>    function maxStake_correctReturnValue(</span>
 339 |     | <span class='neutral'>        uint8 actorIndex</span>
 340 | *   | <span class='executed'>    ) public {</span>
 341 | *   | <span class='executed'>        emit LogUint256(&quot;[maxStake_correctReturnValue] block.timestamp:&quot;, block.timestamp);</span>
 342 |     | <span class='neutral'></span>
 343 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 344 | *   | <span class='executed'>        address actor = address(actors[actorIndex]);</span>
 345 | *   | <span class='executed'>        uint256 maxStake = stakingToken.balanceOf(actor);</span>
 346 |     | <span class='neutral'></span>
 347 | *r  | <span class='executed'>        require(maxStake != 0, &quot;Zero tokens to stake&quot;);</span>
 348 |     | <span class='neutral'></span>
 349 | *   | <span class='executed'>        emit LogString(string.concat(&quot;Max tokens to stake: &quot;, maxStake.toString()));</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>        // Try to stake the max amount</span>
 352 | *   | <span class='executed'>        try actors[actorIndex].stake(maxStake) {</span>
 353 |     | <span class='neutral'>            // check post-conditions here</span>
 354 |     | <span class='neutral'>        } catch {</span>
 355 |     | <span class='unexecuted'>            assert(false);</span>
 356 |     | <span class='neutral'>        }</span>
 357 |     | <span class='neutral'>    }</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>    /* ================================================================</span>
 360 |     | <span class='neutral'>                            Other properties</span>
 361 |     | <span class='neutral'>       ================================================================ */</span>
 362 |     | <span class='neutral'>    </span>
 363 | *   | <span class='executed'>    function test_reward_expiration() public {</span>
 364 |     | <span class='neutral'>    // Advance beyond reward period</span>
 365 | *   | <span class='executed'>    warp(366 days);</span>
 366 |     | <span class='neutral'>    </span>
 367 |     | <span class='neutral'>    // Should not accumulate rewards</span>
 368 | *   | <span class='executed'>    uint256 earnedBefore = staker.earned(address(actors[0]), address(rewardToken1));</span>
 369 | *   | <span class='executed'>    warp(1 days);</span>
 370 | *   | <span class='executed'>    uint256 earnedAfter = staker.earned(address(actors[0]), address(rewardToken1));</span>
 371 |     | <span class='neutral'>    </span>
 372 | *   | <span class='executed'>    assertEq(earnedAfter, earnedBefore, &quot;Rewards should stop after expiration&quot;);</span>
 373 |     | <span class='neutral'>    }</span>
 374 |     | <span class='neutral'>    // Ensure stake never zero</span>
 375 |     | <span class='neutral'>    // This function ensures that the staker&#39;s balance never goes to zero</span>
 376 |     | <span class='neutral'>    // by always staking at least 1 token if the actor has a balance.</span>
 377 |     | <span class='neutral'>    // It also checks that the staker&#39;s balance increases after staking.</span>
 378 |     | <span class='neutral'>    // If the actor has no balance, it will not attempt to stake.</span>
 379 | *   | <span class='executed'>    function stakeNeverZero(uint8 actorIndex, uint256 amount) public {</span>
 380 | *   | <span class='executed'>        emit LogUint256(&quot;[stakeNeverZero] block.timestamp:&quot;, block.timestamp);</span>
 381 |     | <span class='neutral'></span>
 382 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 383 | *   | <span class='executed'>        amount = clampBetween(amount, 1, stakingToken.balanceOf(address(actors[actorIndex])));</span>
 384 |     | <span class='neutral'></span>
 385 | *   | <span class='executed'>        uint256 preStaked = staker.stakedBalanceOf(address(actors[actorIndex]));</span>
 386 | *   | <span class='executed'>        actors[actorIndex].stake(amount);</span>
 387 |     | <span class='neutral'></span>
 388 | *   | <span class='executed'>        uint256 postStaked = staker.stakedBalanceOf(address(actors[actorIndex]));</span>
 389 | *   | <span class='executed'>        assertGt(postStaked, preStaked, &quot;Stake should increase balance&quot;);</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 | *   | <span class='executed'>    function withdrawNeverZero(uint8 actorIndex, uint256 amount) public {</span>
 393 | *   | <span class='executed'>        emit LogUint256(&quot;[withdrawNeverZero] block.timestamp:&quot;, block.timestamp);</span>
 394 |     | <span class='neutral'></span>
 395 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 396 | *   | <span class='executed'>        uint256 userStaked = staker.stakedBalanceOf(address(actors[actorIndex]));</span>
 397 | *r  | <span class='executed'>        require(userStaked &gt; 0, &quot;No staked balance&quot;);</span>
 398 |     | <span class='neutral'></span>
 399 | *   | <span class='executed'>        amount = clampBetween(amount, 1, userStaked);</span>
 400 |     | <span class='neutral'></span>
 401 | *   | <span class='executed'>        uint256 preStaked = userStaked;</span>
 402 | *   | <span class='executed'>        actors[actorIndex].withdraw(amount);</span>
 403 |     | <span class='neutral'></span>
 404 | *   | <span class='executed'>        uint256 postStaked = staker.stakedBalanceOf(address(actors[actorIndex]));</span>
 405 | *   | <span class='executed'>        assertLt(postStaked, preStaked, &quot;Withdraw should decrease balance&quot;);</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'></span>
 408 | *   | <span class='executed'>    function reward_claim_consistency(</span>
 409 |     | <span class='neutral'>        uint8 actorIndex</span>
 410 | *   | <span class='executed'>    ) public {</span>
 411 | *   | <span class='executed'>        emit LogUint256(&quot;[reward_claim_consistency] block.timestamp:&quot;, block.timestamp);</span>
 412 |     | <span class='neutral'></span>
 413 | *   | <span class='executed'>        actorIndex = uint8(clampBetween(actorIndex, 0, actors.length - 1));</span>
 414 | *   | <span class='executed'>        address actorAddr = address(actors[actorIndex]);</span>
 415 |     | <span class='neutral'></span>
 416 | *   | <span class='executed'>        uint256 earned1Before = staker.earned(actorAddr, address(rewardToken1));</span>
 417 | *   | <span class='executed'>        uint256 earned2Before = staker.earned(actorAddr, address(rewardToken2));</span>
 418 |     | <span class='neutral'></span>
 419 | *r  | <span class='executed'>        actors[actorIndex].claimAllRewards();</span>
 420 |     | <span class='neutral'></span>
 421 | *   | <span class='executed'>        uint256 earned1After = staker.earned(actorAddr, address(rewardToken1));</span>
 422 | *   | <span class='executed'>        uint256 earned2After = staker.earned(actorAddr, address(rewardToken2));</span>
 423 |     | <span class='neutral'></span>
 424 | *   | <span class='executed'>        assertEq(earned1After, 0, &quot;Rewards not reset for token1&quot;);</span>
 425 | *   | <span class='executed'>        assertEq(earned2After, 0, &quot;Rewards not reset for token2&quot;);</span>
 426 |     | <span class='neutral'></span>
 427 | *   | <span class='executed'>        if (earned1Before &gt; 0 || earned2Before &gt; 0) {</span>
 428 | *   | <span class='executed'>            emit LogString(</span>
 429 | *   | <span class='executed'>                string.concat(&quot;Claimed rewards: &quot;, earned1Before.toString(), &quot; + &quot;, earned2Before.toString())</span>
 430 |     | <span class='neutral'>            );</span>
 431 |     | <span class='neutral'>        }</span>
 432 |     | <span class='neutral'>    }</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 435 |     | <span class='neutral'>    /*                        ERC20 PROPERTIES                    */</span>
 436 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 437 |     | <span class='neutral'></span>
 438 |     | <span class='neutral'>    // Total supply should only change by mint or burn</span>
 439 |     | <span class='unexecuted'>    function test_ERC20_constantSupply() public view returns (bool) {</span>
 440 |     | <span class='neutral'>        // If token is mintable/burnable, skip this property</span>
 441 |     | <span class='unexecuted'>        uint256 expectedSupply = 1000 ether * actors.length + 200_000 ether; // initial actor + admin mints</span>
 442 |     | <span class='unexecuted'>        return stakingToken.totalSupply() == expectedSupply;</span>
 443 |     | <span class='neutral'>    }</span>
 444 |     | <span class='neutral'></span>
 445 |     | <span class='neutral'>    // User balance must not exceed total supply</span>
 446 |     | <span class='unexecuted'>    function test_ERC20_userBalanceNotExceedSupply() public view returns (bool) {</span>
 447 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 448 |     | <span class='unexecuted'>            if (stakingToken.balanceOf(address(actors[i])) &gt; stakingToken.totalSupply()) {</span>
 449 |     | <span class='unexecuted'>                return false;</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='neutral'>        }</span>
 452 |     | <span class='unexecuted'>        return true;</span>
 453 |     | <span class='neutral'>    }</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>    // No negative balances (redundant in Solidity, but for completeness)</span>
 456 |     | <span class='unexecuted'>    function test_ERC20_noNegativeBalances() public view returns (bool) {</span>
 457 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 458 |     | <span class='unexecuted'>            if (stakingToken.balanceOf(address(actors[i])) &lt; 0) {</span>
 459 |     | <span class='unexecuted'>                return false;</span>
 460 |     | <span class='neutral'>            }</span>
 461 |     | <span class='neutral'>        }</span>
 462 |     | <span class='unexecuted'>        return true;</span>
 463 |     | <span class='neutral'>    }</span>
 464 |     | <span class='neutral'></span>
 465 |     | <span class='neutral'>    // Sum of all balances &lt;= total supply</span>
 466 |     | <span class='unexecuted'>    function echidna_ERC20_sumBalancesNotExceedSupply() public view returns (bool) {</span>
 467 |     | <span class='unexecuted'>        uint256 sum;</span>
 468 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 469 |     | <span class='unexecuted'>            sum += stakingToken.balanceOf(address(actors[i]));</span>
 470 |     | <span class='neutral'>        }</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='unexecuted'>        sum += stakingToken.balanceOf(address(staker));</span>
 473 |     | <span class='unexecuted'>        return sum &lt;= stakingToken.totalSupply();</span>
 474 |     | <span class='neutral'>    }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>    // Address zero should have zero balance</span>
 477 | *   | <span class='executed'>    function test_ERC20external_zeroAddressBalance() public {</span>
 478 | *   | <span class='executed'>        assertEq(stakingToken.balanceOf(address(0)), 0, &quot;Address zero balance not equal to zero&quot;);</span>
 479 |     | <span class='neutral'>    }</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='neutral'>    // Transfers to zero address should not be allowed</span>
 482 |     | <span class='unexecuted'>    function echidna_ERC20external_transferToZeroAddress() public returns (bool) {</span>
 483 |     | <span class='unexecuted'>        if (stakingToken.totalSupply() == 0) return true;</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='unexecuted'>        uint256 balance = stakingToken.balanceOf(address(this));</span>
 486 |     | <span class='unexecuted'>        if (balance == 0) return true;</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='unexecuted'>        try stakingToken.transfer(address(0), balance) {</span>
 489 |     | <span class='unexecuted'>            return false;</span>
 490 |     | <span class='neutral'>        } catch {</span>
 491 |     | <span class='unexecuted'>            return true;</span>
 492 |     | <span class='neutral'>        }</span>
 493 |     | <span class='neutral'>    }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>    // Select an actor by index, clamped to valid range</span>
 496 |     | <span class='neutral'>    function _selectActor(</span>
 497 |     | <span class='neutral'>        uint8 index</span>
 498 |     | <span class='neutral'>    ) internal returns (StakerActor actor) {</span>
 499 |     | <span class='neutral'>        uint256 actorIndex = clampBetween(uint256(index), 0, actors.length - 1);</span>
 500 |     | <span class='neutral'>        return actors[actorIndex];</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='neutral'>    // Overflow check for two uint256 values</span>
 504 |     | <span class='unexecuted'>    function _overflowCheck(uint256 a, uint256 b) internal pure {</span>
 505 |     | <span class='unexecuted'>        uint256 c;</span>
 506 |     | <span class='neutral'>        unchecked {</span>
 507 |     | <span class='unexecuted'>            c = a + b;</span>
 508 |     | <span class='neutral'>        }</span>
 509 |     | <span class='unexecuted'>        require(c &gt;= a, &quot;OVERFLOW!&quot;);</span>
 510 |     | <span class='neutral'>    }</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>    // Get staking token balance of the staker contract</span>
 513 |     | <span class='neutral'>    function _stakingTokenBalanceOfStaker() internal view returns (uint256 assets) {</span>
 514 |     | <span class='neutral'>        assets = stakingToken.balanceOf(address(staker));</span>
 515 |     | <span class='neutral'>    }</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='neutral'>    //Overflow check</span>
 518 | *   | <span class='executed'>    function generate_overflow_stake(</span>
 519 |     | <span class='neutral'>        uint8 actorIndex</span>
 520 |     | <span class='unexecuted'>    ) public {</span>
 521 | *   | <span class='executed'>        uint256 max = type(uint256).max;</span>
 522 | *r  | <span class='executed'>        stakingToken.mint(address(actors[actorIndex]), max);</span>
 523 |     | <span class='unexecuted'>        stake(actorIndex, max);</span>
 524 |     | <span class='neutral'>    }</span>
 525 |     | <span class='neutral'></span>
 526 |     | <span class='unexecuted'>    function echidna_ERC20_sumBalancesNoOverflow() public view returns (bool) {</span>
 527 |     | <span class='unexecuted'>        uint256 sum = 0;</span>
 528 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; actors.length; i++) {</span>
 529 |     | <span class='neutral'>            // overflow check utility before adding</span>
 530 |     | <span class='unexecuted'>            _overflowCheck(sum, stakingToken.balanceOf(address(actors[i])));</span>
 531 |     | <span class='unexecuted'>            sum += stakingToken.balanceOf(address(actors[i]));</span>
 532 |     | <span class='neutral'>        }</span>
 533 |     | <span class='neutral'>        // Check overflow for adding staker contract&#39;s balance</span>
 534 |     | <span class='unexecuted'>        _overflowCheck(sum, stakingToken.balanceOf(address(staker)));</span>
 535 |     | <span class='unexecuted'>        sum += stakingToken.balanceOf(address(staker));</span>
 536 |     | <span class='neutral'></span>
 537 |     | <span class='neutral'>        // The sum should never exceed total supply</span>
 538 |     | <span class='unexecuted'>        return sum &lt;= stakingToken.totalSupply();</span>
 539 |     | <span class='neutral'>    }</span>
 540 |     | <span class='neutral'>}</span>
 541 |     | <span class='neutral'></span>

</code>
<br />

